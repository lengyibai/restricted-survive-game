import{S as Se,M as yn,A as Sn,R as ve,T as Rn,C as Re,r as Te,h as In,a as An,D as Cn,P as vn,G as Tn,b as Mn,c as Vn,E as Ae,L as rs,d as xe,s as os,p as ce,e as as,B as et}from"./game_pixi-CW65XjlF.js";var B=(c=>(c[c.Region=0]="Region",c[c.BoundingBox=1]="BoundingBox",c[c.Mesh=2]="Mesh",c[c.LinkedMesh=3]="LinkedMesh",c[c.Path=4]="Path",c[c.Point=5]="Point",c[c.Clipping=6]="Clipping",c))(B||{});class Ce{constructor(t,r=new Array,s=0,i=new DataView(t.buffer)){this.strings=r,this.index=s,this.buffer=i}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let r=this.readByte(),s=r&127;return r&128&&(r=this.readByte(),s|=(r&127)<<7,r&128&&(r=this.readByte(),s|=(r&127)<<14,r&128&&(r=this.readByte(),s|=(r&127)<<21,r&128&&(r=this.readByte(),s|=(r&127)<<28)))),t?s:s>>>1^-(s&1)}readStringRef(){const t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let r="";for(let s=0;s<t;){const i=this.readUnsignedByte();switch(i>>4){case 12:case 13:r+=String.fromCharCode((i&31)<<6|this.readByte()&63),s+=2;break;case 14:r+=String.fromCharCode((i&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),s+=3;break;default:r+=String.fromCharCode(i),s++}}return r}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}}var R=(c=>(c[c.setup=0]="setup",c[c.first=1]="first",c[c.replace=2]="replace",c[c.add=3]="add",c))(R||{}),K=(c=>(c[c.mixIn=0]="mixIn",c[c.mixOut=1]="mixOut",c))(K||{}),at=(c=>(c[c.Fixed=0]="Fixed",c[c.Percent=1]="Percent",c))(at||{}),vt=(c=>(c[c.Tangent=0]="Tangent",c[c.Chain=1]="Chain",c[c.ChainScale=2]="ChainScale",c))(vt||{}),st=(c=>(c[c.Normal=0]="Normal",c[c.OnlyTranslation=1]="OnlyTranslation",c[c.NoRotationOrReflection=2]="NoRotationOrReflection",c[c.NoScale=3]="NoScale",c[c.NoScaleOrReflection=4]="NoScaleOrReflection",c))(st||{});function Ze(c){switch(c.toLowerCase()){case"nearest":return yt.Nearest;case"linear":return yt.Linear;case"mipmap":return yt.MipMap;case"mipmapnearestnearest":return yt.MipMapNearestNearest;case"mipmaplinearnearest":return yt.MipMapLinearNearest;case"mipmapnearestlinear":return yt.MipMapNearestLinear;case"mipmaplinearlinear":return yt.MipMapLinearLinear;default:throw new Error(`Unknown texture filter ${c}`)}}var yt=(c=>(c[c.Nearest=9728]="Nearest",c[c.Linear=9729]="Linear",c[c.MipMap=9987]="MipMap",c[c.MipMapNearestNearest=9984]="MipMapNearestNearest",c[c.MipMapLinearNearest=9985]="MipMapLinearNearest",c[c.MipMapNearestLinear=9986]="MipMapNearestLinear",c[c.MipMapLinearLinear=9987]="MipMapLinearLinear",c))(yt||{}),le=(c=>(c[c.MirroredRepeat=33648]="MirroredRepeat",c[c.ClampToEdge=33071]="ClampToEdge",c[c.Repeat=10497]="Repeat",c))(le||{});class Fe{constructor(){this.size=null,this.names=null,this.values=null,this.renderObject=null}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}}class Fn{constructor(){this.x=0,this.y=0,this.width=0,this.height=0,this.offsetX=0,this.offsetY=0,this.originalWidth=0,this.originalHeight=0,this.rotate=0,this.index=0}}class Pe{constructor(t,r,s){this.pages=new Array,this.regions=new Array,t&&this.addSpineAtlas(t,r,s)}addTexture(t,r){const s=this.pages;let i=null;for(let m=0;m<s.length;m++)if(s[m].baseTexture===r.baseTexture){i=s[m];break}if(i===null){i=new je,i.name="texturePage";const m=r.baseTexture;i.width=m.realWidth,i.height=m.realHeight,i.baseTexture=m,i.minFilter=i.magFilter=yt.Nearest,i.uWrap=le.ClampToEdge,i.vWrap=le.ClampToEdge,s.push(i)}const o=new Je;return o.name=t,o.page=i,o.texture=r,o.index=-1,this.regions.push(o),o}addTextureHash(t,r){for(const s in t)t.hasOwnProperty(s)&&this.addTexture(r&&s.indexOf(".")!==-1?s.substr(0,s.lastIndexOf(".")):s,t[s])}addSpineAtlas(t,r,s){return this.load(t,r,s)}load(t,r,s){if(r==null)throw new Error("textureLoader cannot be null.");const i=new Pn(t),o=new Array(4);let m=null;const d={};let e=null;d.size=()=>{m.width=parseInt(o[1]),m.height=parseInt(o[2])},d.format=()=>{},d.filter=()=>{m.minFilter=Ze(o[1]),m.magFilter=Ze(o[2])},d.repeat=()=>{o[1].indexOf("x")!=-1&&(m.uWrap=le.Repeat),o[1].indexOf("y")!=-1&&(m.vWrap=le.Repeat)},d.pma=()=>{m.pma=o[1]=="true"};const n={};n.xy=()=>{e.x=parseInt(o[1]),e.y=parseInt(o[2])},n.size=()=>{e.width=parseInt(o[1]),e.height=parseInt(o[2])},n.bounds=()=>{e.x=parseInt(o[1]),e.y=parseInt(o[2]),e.width=parseInt(o[3]),e.height=parseInt(o[4])},n.offset=()=>{e.offsetX=parseInt(o[1]),e.offsetY=parseInt(o[2])},n.orig=()=>{e.originalWidth=parseInt(o[1]),e.originalHeight=parseInt(o[2])},n.offsets=()=>{e.offsetX=parseInt(o[1]),e.offsetY=parseInt(o[2]),e.originalWidth=parseInt(o[3]),e.originalHeight=parseInt(o[4])},n.rotate=()=>{const l=o[1];let u=0;l.toLocaleLowerCase()=="true"?u=6:l.toLocaleLowerCase()=="false"?u=0:u=(720-parseFloat(l))%360/45,e.rotate=u},n.index=()=>{e.index=parseInt(o[1])};let a=i.readLine();for(;a!=null&&a.trim().length==0;)a=i.readLine();for(;!(a==null||a.trim().length==0||i.readEntry(o,a)==0);)a=i.readLine();const h=()=>{for(;;){if(a==null)return s&&s(this);if(a.trim().length==0)m=null,a=i.readLine();else if(m===null){for(m=new je,m.name=a.trim();i.readEntry(o,a=i.readLine())!=0;){const l=d[o[0]];l&&l()}this.pages.push(m),r(m.name,l=>{if(l===null)return this.pages.splice(this.pages.indexOf(m),1),s&&s(null);m.baseTexture=l,m.pma&&(l.alphaMode=Sn.PMA),l.valid||l.setSize(m.width,m.height),m.setFilters(),(!m.width||!m.height)&&(m.width=l.realWidth,m.height=l.realHeight,(!m.width||!m.height)&&console.log(`ERROR spine atlas page ${m.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`)),h()});break}else{e=new Fn;const l=new Je;l.name=a,l.page=m;let u=null,f=null;for(;;){const b=i.readEntry(o,a=i.readLine());if(b==0)break;const y=n[o[0]];if(y)y();else{u==null&&(u=[],f=[]),u.push(o[0]);const S=[];for(let I=0;I<b;I++)S.push(parseInt(o[I+1]));f.push(S)}}e.originalWidth==0&&e.originalHeight==0&&(e.originalWidth=e.width,e.originalHeight=e.height);const g=m.baseTexture.resolution;e.x/=g,e.y/=g,e.width/=g,e.height/=g,e.originalWidth/=g,e.originalHeight/=g,e.offsetX/=g,e.offsetY/=g;const w=e.rotate%4!==0,E=new ve(e.x,e.y,w?e.height:e.width,w?e.width:e.height),x=new ve(0,0,e.originalWidth,e.originalHeight),p=new ve(e.offsetX,e.originalHeight-e.height-e.offsetY,e.width,e.height);l.texture=new Rn(l.page.baseTexture,E,x,p,e.rotate),l.index=e.index,l.texture.updateUvs(),this.regions.push(l)}}};h()}findRegion(t){for(let r=0;r<this.regions.length;r++)if(this.regions[r].name==t)return this.regions[r];return null}dispose(){for(let t=0;t<this.pages.length;t++)this.pages[t].baseTexture.dispose()}}class Pn{constructor(t){this.index=0,this.lines=t.split(/\r\n|\r|\n/)}readLine(){return this.index>=this.lines.length?null:this.lines[this.index++]}readEntry(t,r){if(r==null||(r=r.trim(),r.length==0))return 0;const s=r.indexOf(":");if(s==-1)return 0;t[0]=r.substr(0,s).trim();for(let i=1,o=s+1;;i++){const m=r.indexOf(",",o);if(m==-1)return t[i]=r.substr(o).trim(),i;if(t[i]=r.substr(o,m-o).trim(),o=m+1,i==4)return 4}}}class je{constructor(){this.minFilter=yt.Nearest,this.magFilter=yt.Nearest,this.uWrap=le.ClampToEdge,this.vWrap=le.ClampToEdge}setFilters(){const t=this.baseTexture,r=this.minFilter;r==yt.Linear?t.scaleMode=Se.LINEAR:this.minFilter==yt.Nearest?t.scaleMode=Se.NEAREST:(t.mipmap=yn.POW2,r==yt.MipMapNearestNearest?t.scaleMode=Se.NEAREST:t.scaleMode=Se.LINEAR)}}class Je extends Fe{}class kn{constructor(){this.entries={},this.size=0}add(t){const r=this.entries[t];return this.entries[t]=!0,r?!1:(this.size++,!0)}addAll(t){const r=this.size;for(let s=0,i=t.length;s<i;s++)this.add(t[s]);return r!=this.size}contains(t){return this.entries[t]}clear(){this.entries={},this.size=0}}const de=class{constructor(c=0,t=0,r=0,s=0){this.r=c,this.g=t,this.b=r,this.a=s}set(c,t,r,s){return this.r=c,this.g=t,this.b=r,this.a=s,this.clamp()}setFromColor(c){return this.r=c.r,this.g=c.g,this.b=c.b,this.a=c.a,this}setFromString(c){return c=c.charAt(0)=="#"?c.substr(1):c,this.r=parseInt(c.substr(0,2),16)/255,this.g=parseInt(c.substr(2,2),16)/255,this.b=parseInt(c.substr(4,2),16)/255,this.a=c.length!=8?1:parseInt(c.substr(6,2),16)/255,this}add(c,t,r,s){return this.r+=c,this.g+=t,this.b+=r,this.a+=s,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(c,t){c.r=((t&4278190080)>>>24)/255,c.g=((t&16711680)>>>16)/255,c.b=((t&65280)>>>8)/255,c.a=(t&255)/255}static rgb888ToColor(c,t){c.r=((t&16711680)>>>16)/255,c.g=((t&65280)>>>8)/255,c.b=(t&255)/255}static fromString(c){return new de().setFromString(c)}};let T=de;T.WHITE=new de(1,1,1,1);T.RED=new de(1,0,0,1);T.GREEN=new de(0,1,0,1);T.BLUE=new de(0,0,1,1);T.MAGENTA=new de(1,0,1,1);const Zt=class{static clamp(c,t,r){return c<t?t:c>r?r:c}static cosDeg(c){return Math.cos(c*Zt.degRad)}static sinDeg(c){return Math.sin(c*Zt.degRad)}static signum(c){return Math.sign(c)}static toInt(c){return c>0?Math.floor(c):Math.ceil(c)}static cbrt(c){const t=Math.pow(Math.abs(c),.3333333333333333);return c<0?-t:t}static randomTriangular(c,t){return Zt.randomTriangularWith(c,t,(c+t)*.5)}static randomTriangularWith(c,t,r){const s=Math.random(),i=t-c;return s<=(r-c)/i?c+Math.sqrt(s*i*(r-c)):t-Math.sqrt((1-s)*i*(t-r))}static isPowerOfTwo(c){return c&&(c&c-1)===0}};let F=Zt;F.PI=3.1415927;F.PI2=Zt.PI*2;F.radiansToDegrees=180/Zt.PI;F.radDeg=Zt.radiansToDegrees;F.degreesToRadians=Zt.PI/180;F.degRad=Zt.degreesToRadians;class Nn{apply(t,r,s){return t+(r-t)*this.applyInternal(s)}}class Yn extends Nn{constructor(t){super(),this.power=2,this.power=t}applyInternal(t){return t<=.5?Math.pow(t*2,this.power)/2:Math.pow((t-1)*2,this.power)/(this.power%2==0?-2:2)+1}}class is extends Yn{applyInternal(t){return Math.pow(t-1,this.power)*(this.power%2==0?-1:1)+1}}const me=class{static arrayCopy(c,t,r,s,i){for(let o=t,m=s;o<t+i;o++,m++)r[m]=c[o]}static arrayFill(c,t,r,s){for(let i=t;i<r;i++)c[i]=s}static setArraySize(c,t,r=0){const s=c.length;if(s==t)return c;if(c.length=t,s<t)for(let i=s;i<t;i++)c[i]=r;return c}static ensureArrayCapacity(c,t,r=0){return c.length>=t?c:me.setArraySize(c,t,r)}static newArray(c,t){const r=new Array(c);for(let s=0;s<c;s++)r[s]=t;return r}static newFloatArray(c){if(me.SUPPORTS_TYPED_ARRAYS)return new Float32Array(c);const t=new Array(c);for(let r=0;r<t.length;r++)t[r]=0;return t}static newShortArray(c){if(me.SUPPORTS_TYPED_ARRAYS)return new Int16Array(c);const t=new Array(c);for(let r=0;r<t.length;r++)t[r]=0;return t}static toFloatArray(c){return me.SUPPORTS_TYPED_ARRAYS?new Float32Array(c):c}static toSinglePrecision(c){return me.SUPPORTS_TYPED_ARRAYS?Math.fround(c):c}static webkit602BugfixHelper(c,t){}static contains(c,t,r=!0){for(let s=0;s<c.length;s++)if(c[s]==t)return!0;return!1}static enumValue(c,t){return c[t[0].toUpperCase()+t.slice(1)]}};let C=me;C.SUPPORTS_TYPED_ARRAYS=typeof Float32Array<"u";const Xn={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0},Jt=[0,0,0];class Bn extends Mn{constructor(){super(...arguments),this.region=null,this.attachment=null}}class Ln extends Vn{constructor(t,r,s,i,o){super(t,r,s,i,o),this.region=null,this.attachment=null}}const ls=class extends Re{constructor(c){if(super(),!c)throw new Error("The spineData param is required.");if(typeof c=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=c,this.createSkeleton(c),this.slotContainers=[],this.tempClipContainers=[];for(let t=0,r=this.skeleton.slots.length;t<r;t++){const s=this.skeleton.slots[t],i=s.getAttachment(),o=this.newContainer();if(this.slotContainers.push(o),this.addChild(o),this.tempClipContainers.push(null),!!i)if(i.type===B.Region){const m=i.name,d=this.createSprite(s,i,m);s.currentSprite=d,s.currentSpriteName=m,o.addChild(d)}else if(i.type===B.Mesh){const m=this.createMesh(s,i);s.currentMesh=m,s.currentMeshId=i.id,s.currentMeshName=i.name,o.addChild(m)}else i.type===B.Clipping&&(this.createGraphics(s,i),o.addChild(s.clippingContainer),o.addChild(s.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(c){var t;c!=this._debug&&((t=this._debug)==null||t.unregisterSpine(this),c==null||c.registerSpine(this),this._debug=c)}get autoUpdate(){return this._autoUpdate}set autoUpdate(c){c!==this._autoUpdate&&(this._autoUpdate=c,this.updateTransform=c?ls.prototype.autoUpdateTransform:Re.prototype.updateTransform)}get tint(){return Te(this.tintRgb)}set tint(c){this.tintRgb=In(c,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit<"u"?this.localDelayLimit:Xn.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(c){var n;const t=this.delayLimit;if(c>t&&(c=t),this.state.update(c),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform();const r=this.skeleton.slots,s=this.color;let i=null,o=null;s?(i=s.light,o=s.dark):i=this.tintRgb;for(let a=0,h=r.length;a<h;a++){const l=r[a],u=l.getAttachment(),f=this.slotContainers[a];if(!u){f.visible=!1;continue}let g=null;u.sequence&&u.sequence.apply(l,u);let w=u.region;const E=u.color;switch(u!=null&&u.type){case B.Region:if(f.transform.setFromMatrix(l.bone.matrix),w=u.region,l.currentMesh&&(l.currentMesh.visible=!1,l.currentMesh=null,l.currentMeshId=void 0,l.currentMeshName=void 0),!w){l.currentSprite&&(l.currentSprite.renderable=!1);break}if(!l.currentSpriteName||l.currentSpriteName!==u.name){const b=u.name;if(l.currentSprite&&(l.currentSprite.visible=!1),l.sprites=l.sprites||{},l.sprites[b]!==void 0)l.sprites[b].visible=!0;else{const y=this.createSprite(l,u,b);f.addChild(y)}l.currentSprite=l.sprites[b],l.currentSpriteName=b}l.currentSprite.renderable=!0,l.hackRegion||this.setSpriteRegion(u,l.currentSprite,w),l.currentSprite.color?g=l.currentSprite.color:(Jt[0]=i[0]*l.color.r*E.r,Jt[1]=i[1]*l.color.g*E.g,Jt[2]=i[2]*l.color.b*E.b,l.currentSprite.tint=Te(Jt)),l.currentSprite.blendMode=l.blendMode;break;case B.Mesh:if(l.currentSprite){l.currentSprite.visible=!1,l.currentSprite=null,l.currentSpriteName=void 0;const b=new An;b._parentID=-1,b._worldID=f.transform._worldID,f.transform=b}if(!w){l.currentMesh&&(l.currentMesh.renderable=!1);break}const p=u.id;if(l.currentMeshId===void 0||l.currentMeshId!==p){const b=p;if(l.currentMesh&&(l.currentMesh.visible=!1),l.meshes=l.meshes||{},l.meshes[b]!==void 0)l.meshes[b].visible=!0;else{const y=this.createMesh(l,u);f.addChild(y)}l.currentMesh=l.meshes[b],l.currentMeshName=u.name,l.currentMeshId=b}l.currentMesh.renderable=!0,u.computeWorldVerticesOld(l,l.currentMesh.vertices),l.currentMesh.color?g=l.currentMesh.color:(Jt[0]=i[0]*l.color.r*E.r,Jt[1]=i[1]*l.color.g*E.g,Jt[2]=i[2]*l.color.b*E.b,l.currentMesh.tint=Te(Jt)),l.currentMesh.blendMode=l.blendMode,l.hackRegion||this.setMeshRegion(u,l.currentMesh,w);break;case B.Clipping:l.currentGraphics||(this.createGraphics(l,u),f.addChild(l.clippingContainer),f.addChild(l.currentGraphics)),this.updateGraphics(l,u),f.alpha=1,f.visible=!0;continue;default:f.visible=!1;continue}if(f.visible=!0,g){let x=l.color.r*E.r,p=l.color.g*E.g,b=l.color.b*E.b;g.setLight(i[0]*x+o[0]*(1-x),i[1]*p+o[1]*(1-p),i[2]*b+o[2]*(1-b)),l.darkColor?(x=l.darkColor.r,p=l.darkColor.g,b=l.darkColor.b):(x=0,p=0,b=0),g.setDark(i[0]*x+o[0]*(1-x),i[1]*p+o[1]*(1-p),i[2]*b+o[2]*(1-b))}f.alpha=l.color.a}const m=this.skeleton.drawOrder;let d=null,e=null;for(let a=0,h=m.length;a<h;a++){const l=r[m[a].data.index],u=this.slotContainers[m[a].data.index];if(e||u.parent!==null&&u.parent!==this&&(u.parent.removeChild(u),u.parent=this),l.currentGraphics&&l.getAttachment())e=l.clippingContainer,d=l.getAttachment(),e.children.length=0,this.children[a]=u,d.endSlot===l.data&&(d.endSlot=null);else if(e){let f=this.tempClipContainers[a];f||(f=this.tempClipContainers[a]=this.newContainer(),f.visible=!1),this.children[a]=f,u.parent=null,e.addChild(u),d.endSlot==l.data&&(e.renderable=!0,e=null,d=null)}else this.children[a]=u}(n=this._debug)==null||n.renderDebug(this)}setSpriteRegion(c,t,r){t.attachment===c&&t.region===r||(t.region=r,t.attachment=c,t.texture=r.texture,t.rotation=c.rotation*F.degRad,t.position.x=c.x,t.position.y=c.y,t.alpha=c.color.a,r.size?(t.scale.x=r.size.width/r.originalWidth,t.scale.y=-r.size.height/r.originalHeight):(t.scale.x=c.scaleX*c.width/r.originalWidth,t.scale.y=-c.scaleY*c.height/r.originalHeight))}setMeshRegion(c,t,r){t.attachment===c&&t.region===r||(t.region=r,t.attachment=c,t.texture=r.texture,r.texture.updateUvs(),t.uvBuffer.update(c.regionUVs))}autoUpdateTransform(){{this.lastTime=this.lastTime||Date.now();const c=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(c)}Re.prototype.updateTransform.call(this)}createSprite(c,t,r){let s=t.region;c.hackAttachment===t&&(s=c.hackRegion);const i=s?s.texture:null,o=this.newSprite(i);return o.anchor.set(.5),s&&this.setSpriteRegion(t,o,t.region),c.sprites=c.sprites||{},c.sprites[r]=o,o}createMesh(c,t){let r=t.region;c.hackAttachment===t&&(r=c.hackRegion,c.hackAttachment=null,c.hackRegion=null);const s=this.newMesh(r?r.texture:null,new Float32Array(t.regionUVs.length),t.regionUVs,new Uint16Array(t.triangles),Cn.TRIANGLES);return typeof s._canvasPadding<"u"&&(s._canvasPadding=1.5),s.alpha=t.color.a,s.region=t.region,r&&this.setMeshRegion(t,s,r),c.meshes=c.meshes||{},c.meshes[t.id]=s,s}createGraphics(c,t){const r=this.newGraphics(),s=new vn([]);return r.clear(),r.beginFill(16777215,1),r.drawPolygon(s),r.renderable=!1,c.currentGraphics=r,c.clippingContainer=this.newContainer(),c.clippingContainer.mask=c.currentGraphics,r}updateGraphics(c,t){const r=c.currentGraphics.geometry,s=r.graphicsData[0].shape.points,i=t.worldVerticesLength;s.length=i,t.computeWorldVertices(c,0,i,s,0,2),r.invalidate()}hackTextureBySlotIndex(c,t=null,r=null){const s=this.skeleton.slots[c];if(!s)return!1;const i=s.getAttachment();let o=i.region;return t?(o=new Fe,o.texture=t,o.size=r,s.hackRegion=o,s.hackAttachment=i):(s.hackRegion=null,s.hackAttachment=null),s.currentSprite?this.setSpriteRegion(i,s.currentSprite,o):s.currentMesh&&this.setMeshRegion(i,s.currentMesh,o),!0}hackTextureBySlotName(c,t=null,r=null){const s=this.skeleton.findSlotIndex(c);return s==-1?!1:this.hackTextureBySlotIndex(s,t,r)}hackTextureAttachment(c,t,r,s=null){const i=this.skeleton.findSlotIndex(c),o=this.skeleton.getAttachmentByName(c,t);o.region.texture=r;const m=this.skeleton.slots[i];if(!m)return!1;const d=m.getAttachment();if(t===d.name){let e=o.region;return r?(e=new Fe,e.texture=r,e.size=s,m.hackRegion=e,m.hackAttachment=d):(m.hackRegion=null,m.hackAttachment=null),m.currentSprite&&m.currentSprite.region!=e?(this.setSpriteRegion(d,m.currentSprite,e),m.currentSprite.region=e):m.currentMesh&&m.currentMesh.region!=e&&this.setMeshRegion(d,m.currentMesh,e),!0}return!1}newContainer(){return new Re}newSprite(c){return new Bn(c)}newGraphics(){return new Tn}newMesh(c,t,r,s,i){return new Ln(c,t,r,s,i)}transformHack(){return 1}hackAttachmentGroups(c,t,r){if(!c)return;const s=[],i=[];for(let o=0,m=this.skeleton.slots.length;o<m;o++){const d=this.skeleton.slots[o],e=d.currentSpriteName||d.currentMeshName||"",n=d.currentSprite||d.currentMesh;e.endsWith(c)?(n.parentGroup=t,i.push(n)):r&&n&&(n.parentGroup=r,s.push(n))}return[s,i]}destroy(c){this.debug=null;for(let t=0,r=this.skeleton.slots.length;t<r;t++){const s=this.skeleton.slots[t];for(const i in s.meshes)s.meshes[i].destroy(c);s.meshes=null;for(const i in s.sprites)s.sprites[i].destroy(c);s.sprites=null}for(let t=0,r=this.slotContainers.length;t<r;t++)this.slotContainers[t].destroy(c);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(c)}};let cs=ls;cs.clippingPolygon=[];Object.defineProperty(cs.prototype,"visible",{get(){return this._visible},set(c){c!==this._visible&&(this._visible=c,c&&(this.lastTime=0))}});const On={extension:Ae.Asset,loader:{extension:{type:Ae.LoadParser,priority:rs.Normal},test(c){return xe(c,".atlas")},async load(c){return await(await os.ADAPTER.fetch(c)).text()},testParse(c,t){const r=xe(t.src,".atlas"),s=typeof c=="string";return Promise.resolve(r&&s)},async parse(c,t,r){const s=t.data;let i=ce.dirname(t.src);i&&i.lastIndexOf("/")!==i.length-1&&(i+="/");let o=null,m=null;const d=new Promise((a,h)=>{o=a,m=h});let e;const n=a=>{a||m(`Something went terribly wrong loading a spine .atlas file
Most likely your texture failed to load.`),o(e)};if(s.image||s.images){const a=Object.assign(s.image?{default:s.image}:{},s.images);e=new Pe(c,(h,l)=>{const u=a[h]||a.default;u&&u.baseTexture?l(u.baseTexture):l(u)},n)}else e=new Pe(c,hs(r,i,s.imageMetadata),n);return await d},unload(c){c.dispose()}}},hs=(c,t,r)=>async(s,i)=>{const o=ce.normalize([...t.split(ce.sep),s].join(ce.sep)),m=await c.load({src:o,data:r});i(m.baseTexture)};as.add(On);function Ke(c){return c.hasOwnProperty("bones")}function _n(c){return c instanceof ArrayBuffer}class $n{constructor(){}installLoader(){const t=this,r={extension:Ae.Asset,loader:{extension:{type:Ae.LoadParser,priority:rs.Normal},test(s){return xe(s,".skel")},async load(s){return await(await os.ADAPTER.fetch(s)).arrayBuffer()},testParse(s,i){var e;const o=xe(i.src,".json")&&Ke(s),m=xe(i.src,".skel")&&_n(s),d=((e=i.data)==null?void 0:e.spineAtlas)===!1;return Promise.resolve(o&&!d||m)},async parse(s,i,o){const m=ce.extname(i.src).toLowerCase(),d=ce.basename(i.src,m);let e=ce.dirname(i.src);e&&e.lastIndexOf("/")!==e.length-1&&(e+="/");const n=xe(i.src,".json")&&Ke(s);let a=null,h=s;n?a=t.createJsonParser():(a=t.createBinaryParser(),h=new Uint8Array(s));const l=i.data||{},u=(l==null?void 0:l.spineSkeletonScale)??null;u&&(a.scale=u);const f=l.spineAtlas;if(f&&f.pages)return t.parseData(a,f,h);const g=l.atlasRawData;if(g){let x=null,p=null;const b=new Promise((I,v)=>{x=I,p=v}),y=new Pe(g,hs(o,e,l.imageMetadata),I=>{I||p(`Something went terribly wrong loading a spine .atlas file
Most likely your texture failed to load.`),x(y)}),S=await b;return t.parseData(a,S,h)}let w=l.spineAtlasFile;w||(w=`${e+d}.atlas`);const E=await o.load({src:w,data:l,alias:l.spineAtlasAlias});return t.parseData(a,E,h)}}};return as.add(r),r}}let ds=class{constructor(t){if(t==null)throw new Error("name cannot be null.");this.name=t}};const us=class extends ds{constructor(t){super(t),this.id=(us.nextID++&65535)<<11,this.worldVerticesLength=0,this.deformAttachment=this}computeWorldVerticesOld(t,r){this.computeWorldVertices(t,0,this.worldVerticesLength,r,0,2)}computeWorldVertices(t,r,s,i,o,m){s=o+(s>>1)*m;const d=t.bone.skeleton,e=t.deform;let n=this.vertices;const a=this.bones;if(a==null){e.length>0&&(n=e);const f=t.bone.matrix,g=f.tx,w=f.ty,E=f.a,x=f.c,p=f.b,b=f.d;for(let y=r,S=o;S<s;y+=2,S+=m){const I=n[y],v=n[y+1];i[S]=I*E+v*x+g,i[S+1]=I*p+v*b+w}return}let h=0,l=0;for(let f=0;f<r;f+=2){const g=a[h];h+=g+1,l+=g}const u=d.bones;if(e.length==0)for(let f=o,g=l*3;f<s;f+=m){let w=0,E=0,x=a[h++];for(x+=h;h<x;h++,g+=3){const p=u[a[h]].matrix,b=n[g],y=n[g+1],S=n[g+2];w+=(b*p.a+y*p.c+p.tx)*S,E+=(b*p.b+y*p.d+p.ty)*S}i[f]=w,i[f+1]=E}else{const f=e;for(let g=o,w=l*3,E=l<<1;g<s;g+=m){let x=0,p=0,b=a[h++];for(b+=h;h<b;h++,w+=3,E+=2){const y=u[a[h]].matrix,S=n[w]+f[E],I=n[w+1]+f[E+1],v=n[w+2];x+=(S*y.a+I*y.c+y.tx)*v,p+=(S*y.b+I*y.d+y.ty)*v}i[g]=x,i[g+1]=p}}}copyTo(t){this.bones!=null?(t.bones=new Array(this.bones.length),C.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,this.vertices!=null?(t.vertices=C.newFloatArray(this.vertices.length),C.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)):t.vertices=null,t.worldVerticesLength=this.worldVerticesLength,t.deformAttachment=this.deformAttachment}};let ue=us;ue.nextID=0;let Dn=class fs extends ue{constructor(t){super(t),this.type=B.BoundingBox,this.color=new T(1,1,1,1)}copy(){const t=new fs(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}},Un=class ms extends ue{constructor(t){super(t),this.type=B.Clipping,this.color=new T(.2275,.2275,.8078,1)}copy(){const t=new ms(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}},gs=class ke extends ue{constructor(t){super(t),this.type=B.Mesh,this.color=new T(1,1,1,1),this.tempColor=new T(0,0,0,0)}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh!=null)return this.newLinkedMesh();const t=new ke(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),C.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),C.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges!=null&&(t.edges=new Array(this.edges.length),C.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new ke(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh!=null?this.parentMesh:this),t}},zn=class ws extends ue{constructor(t){super(t),this.type=B.Path,this.closed=!1,this.constantSpeed=!1,this.color=new T(1,1,1,1)}copy(){const t=new ws(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),C.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}},Gn=class xs extends ue{constructor(t){super(t),this.type=B.Point,this.color=new T(.38,.94,0,1)}computeWorldPosition(t,r){const s=t.matrix;return r.x=this.x*s.a+this.y*s.c+t.worldX,r.y=this.x*s.b+this.y*s.d+t.worldY,r}computeWorldRotation(t){const r=t.matrix,s=F.cosDeg(this.rotation),i=F.sinDeg(this.rotation),o=s*r.a+i*r.c,m=s*r.b+i*r.d;return Math.atan2(m,o)*F.radDeg}copy(){const t=new xs(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}},Hn=class{constructor(t,r){if(this.deform=new Array,t==null)throw new Error("data cannot be null.");if(r==null)throw new Error("bone cannot be null.");this.data=t,this.bone=r,this.color=new T,this.darkColor=t.darkColor==null?null:new T,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}};const lt=class extends ds{constructor(t){super(t),this.type=B.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new T(1,1,1,1),this.offset=C.newFloatArray(8),this.uvs=C.newFloatArray(8),this.tempColor=new T(1,1,1,1)}updateOffset(){const t=this.width/this.region.originalWidth*this.scaleX,r=this.height/this.region.originalHeight*this.scaleY,s=-this.width/2*this.scaleX+this.region.offsetX*t,i=-this.height/2*this.scaleY+this.region.offsetY*r,o=s+this.region.width*t,m=i+this.region.height*r,d=this.rotation*Math.PI/180,e=Math.cos(d),n=Math.sin(d),a=s*e+this.x,h=s*n,l=i*e+this.y,u=i*n,f=o*e+this.x,g=o*n,w=m*e+this.y,E=m*n,x=this.offset;x[lt.OX1]=a-u,x[lt.OY1]=l+h,x[lt.OX2]=a-E,x[lt.OY2]=w+h,x[lt.OX3]=f-E,x[lt.OY3]=w+g,x[lt.OX4]=f-u,x[lt.OY4]=l+g}setRegion(t){this.region=t;const r=this.uvs;t.rotate?(r[2]=t.u,r[3]=t.v2,r[4]=t.u,r[5]=t.v,r[6]=t.u2,r[7]=t.v,r[0]=t.u2,r[1]=t.v2):(r[0]=t.u,r[1]=t.v2,r[2]=t.u,r[3]=t.v,r[4]=t.u2,r[5]=t.v,r[6]=t.u2,r[7]=t.v2)}computeWorldVertices(t,r,s,i){const o=this.offset,m=t instanceof Hn?t.bone.matrix:t.matrix,d=m.tx,e=m.ty,n=m.a,a=m.c,h=m.b,l=m.d;let u=0,f=0;u=o[lt.OX1],f=o[lt.OY1],r[s]=u*n+f*a+d,r[s+1]=u*h+f*l+e,s+=i,u=o[lt.OX2],f=o[lt.OY2],r[s]=u*n+f*a+d,r[s+1]=u*h+f*l+e,s+=i,u=o[lt.OX3],f=o[lt.OY3],r[s]=u*n+f*a+d,r[s+1]=u*h+f*l+e,s+=i,u=o[lt.OX4],f=o[lt.OY4],r[s]=u*n+f*a+d,r[s+1]=u*h+f*l+e}copy(){const t=new lt(this.name);return t.region=this.region,t.rendererObject=this.rendererObject,t.path=this.path,t.x=this.x,t.y=this.y,t.scaleX=this.scaleX,t.scaleY=this.scaleY,t.rotation=this.rotation,t.width=this.width,t.height=this.height,C.arrayCopy(this.uvs,0,t.uvs,0,8),C.arrayCopy(this.offset,0,t.offset,0,8),t.color.setFromColor(this.color),t}};let Y=lt;Y.OX1=0;Y.OY1=1;Y.OX2=2;Y.OY2=3;Y.OX3=4;Y.OY3=5;Y.OX4=6;Y.OY4=7;Y.X1=0;Y.Y1=1;Y.C1R=2;Y.C1G=3;Y.C1B=4;Y.C1A=5;Y.U1=6;Y.V1=7;Y.X2=8;Y.Y2=9;Y.C2R=10;Y.C2G=11;Y.C2B=12;Y.C2A=13;Y.U2=14;Y.V2=15;Y.X3=16;Y.Y3=17;Y.C3R=18;Y.C3G=19;Y.C3B=20;Y.C3A=21;Y.U3=22;Y.V3=23;Y.X4=24;Y.Y4=25;Y.C4R=26;Y.C4G=27;Y.C4B=28;Y.C4A=29;Y.U4=30;Y.V4=31;new is(2);let ht=class{constructor(t,r,s){if(t==null)throw new Error("name cannot be null.");if(r==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=r,this.timelineIds=[];for(let i=0;i<r.length;i++)this.timelineIds[r[i].getPropertyId()]=!0;this.duration=s}hasTimeline(t){return this.timelineIds[t]==!0}apply(t,r,s,i,o,m,d,e){if(t==null)throw new Error("skeleton cannot be null.");i&&this.duration!=0&&(s%=this.duration,r>0&&(r%=this.duration));const n=this.timelines;for(let a=0,h=n.length;a<h;a++)n[a].apply(t,r,s,o,m,d,e)}static binarySearch(t,r,s=1){let i=0,o=t.length/s-2;if(o==0)return s;let m=o>>>1;for(;;){if(t[(m+1)*s]<=r?i=m+1:o=m,i==o)return(i+1)*s;m=i+o>>>1}}static linearSearch(t,r,s){for(let i=0,o=t.length-s;i<=o;i+=s)if(t[i]>r)return i;return-1}};const Q=class{constructor(t){if(t<=0)throw new Error(`frameCount must be > 0: ${t}`);this.curves=C.newFloatArray((t-1)*Q.BEZIER_SIZE)}getFrameCount(){return this.curves.length/Q.BEZIER_SIZE+1}setLinear(t){this.curves[t*Q.BEZIER_SIZE]=Q.LINEAR}setStepped(t){this.curves[t*Q.BEZIER_SIZE]=Q.STEPPED}getCurveType(t){const r=t*Q.BEZIER_SIZE;if(r==this.curves.length)return Q.LINEAR;const s=this.curves[r];return s==Q.LINEAR?Q.LINEAR:s==Q.STEPPED?Q.STEPPED:Q.BEZIER}setCurve(t,r,s,i,o){const m=(-r*2+i)*.03,d=(-s*2+o)*.03,e=((r-i)*3+1)*.006,n=((s-o)*3+1)*.006;let a=m*2+e,h=d*2+n,l=r*.3+m+e*.16666667,u=s*.3+d+n*.16666667,f=t*Q.BEZIER_SIZE;const g=this.curves;g[f++]=Q.BEZIER;let w=l,E=u;for(let x=f+Q.BEZIER_SIZE-1;f<x;f+=2)g[f]=w,g[f+1]=E,l+=a,u+=h,a+=e,h+=n,w+=l,E+=u}getCurvePercent(t,r){r=F.clamp(r,0,1);const s=this.curves;let i=t*Q.BEZIER_SIZE;const o=s[i];if(o==Q.LINEAR)return r;if(o==Q.STEPPED)return 0;i++;let m=0;for(let e=i,n=i+Q.BEZIER_SIZE-1;i<n;i+=2)if(m=s[i],m>=r){let a,h;return i==e?(a=0,h=0):(a=s[i-2],h=s[i-1]),h+(s[i+1]-h)*(r-a)/(m-a)}const d=s[i-1];return d+(1-d)*(r-m)/(1-m)}};let At=Q;At.LINEAR=0;At.STEPPED=1;At.BEZIER=2;At.BEZIER_SIZE=10*2-1;const Kt=class extends At{constructor(t){super(t),this.frames=C.newFloatArray(t<<1)}getPropertyId(){return 0+this.boneIndex}setFrame(t,r,s){t<<=1,this.frames[t]=r,this.frames[t+Kt.ROTATION]=s}apply(t,r,s,i,o,m,d){const e=this.frames,n=t.bones[this.boneIndex];if(!n.active)return;if(s<e[0]){switch(m){case R.setup:n.rotation=n.data.rotation;return;case R.first:const g=n.data.rotation-n.rotation;n.rotation+=(g-(16384-(16384.499999999996-g/360|0))*360)*o}return}if(s>=e[e.length-Kt.ENTRIES]){let g=e[e.length+Kt.PREV_ROTATION];switch(m){case R.setup:n.rotation=n.data.rotation+g*o;break;case R.first:case R.replace:g+=n.data.rotation-n.rotation,g-=(16384-(16384.499999999996-g/360|0))*360;case R.add:n.rotation+=g*o}return}const a=ht.binarySearch(e,s,Kt.ENTRIES),h=e[a+Kt.PREV_ROTATION],l=e[a],u=this.getCurvePercent((a>>1)-1,1-(s-l)/(e[a+Kt.PREV_TIME]-l));let f=e[a+Kt.ROTATION]-h;switch(f=h+(f-(16384-(16384.499999999996-f/360|0))*360)*u,m){case R.setup:n.rotation=n.data.rotation+(f-(16384-(16384.499999999996-f/360|0))*360)*o;break;case R.first:case R.replace:f+=n.data.rotation-n.rotation;case R.add:n.rotation+=(f-(16384-(16384.499999999996-f/360|0))*360)*o}}};let oe=Kt;oe.ENTRIES=2;oe.PREV_TIME=-2;oe.PREV_ROTATION=-1;oe.ROTATION=1;const wt=class extends At{constructor(t){super(t),this.frames=C.newFloatArray(t*wt.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(t,r,s,i){t*=wt.ENTRIES,this.frames[t]=r,this.frames[t+wt.X]=s,this.frames[t+wt.Y]=i}apply(t,r,s,i,o,m,d){const e=this.frames,n=t.bones[this.boneIndex];if(!n.active)return;if(s<e[0]){switch(m){case R.setup:n.x=n.data.x,n.y=n.data.y;return;case R.first:n.x+=(n.data.x-n.x)*o,n.y+=(n.data.y-n.y)*o}return}let a=0,h=0;if(s>=e[e.length-wt.ENTRIES])a=e[e.length+wt.PREV_X],h=e[e.length+wt.PREV_Y];else{const l=ht.binarySearch(e,s,wt.ENTRIES);a=e[l+wt.PREV_X],h=e[l+wt.PREV_Y];const u=e[l],f=this.getCurvePercent(l/wt.ENTRIES-1,1-(s-u)/(e[l+wt.PREV_TIME]-u));a+=(e[l+wt.X]-a)*f,h+=(e[l+wt.Y]-h)*f}switch(m){case R.setup:n.x=n.data.x+a*o,n.y=n.data.y+h*o;break;case R.first:case R.replace:n.x+=(n.data.x+a-n.x)*o,n.y+=(n.data.y+h-n.y)*o;break;case R.add:n.x+=a*o,n.y+=h*o}}};let Tt=wt;Tt.ENTRIES=3;Tt.PREV_TIME=-3;Tt.PREV_X=-2;Tt.PREV_Y=-1;Tt.X=1;Tt.Y=2;let Es=class kt extends Tt{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,r,s,i,o,m,d){const e=this.frames,n=t.bones[this.boneIndex];if(!n.active)return;if(s<e[0]){switch(m){case R.setup:n.scaleX=n.data.scaleX,n.scaleY=n.data.scaleY;return;case R.first:n.scaleX+=(n.data.scaleX-n.scaleX)*o,n.scaleY+=(n.data.scaleY-n.scaleY)*o}return}let a=0,h=0;if(s>=e[e.length-kt.ENTRIES])a=e[e.length+kt.PREV_X]*n.data.scaleX,h=e[e.length+kt.PREV_Y]*n.data.scaleY;else{const l=ht.binarySearch(e,s,kt.ENTRIES);a=e[l+kt.PREV_X],h=e[l+kt.PREV_Y];const u=e[l],f=this.getCurvePercent(l/kt.ENTRIES-1,1-(s-u)/(e[l+kt.PREV_TIME]-u));a=(a+(e[l+kt.X]-a)*f)*n.data.scaleX,h=(h+(e[l+kt.Y]-h)*f)*n.data.scaleY}if(o==1)m==R.add?(n.scaleX+=a-n.data.scaleX,n.scaleY+=h-n.data.scaleY):(n.scaleX=a,n.scaleY=h);else{let l=0,u=0;if(d==K.mixOut)switch(m){case R.setup:l=n.data.scaleX,u=n.data.scaleY,n.scaleX=l+(Math.abs(a)*F.signum(l)-l)*o,n.scaleY=u+(Math.abs(h)*F.signum(u)-u)*o;break;case R.first:case R.replace:l=n.scaleX,u=n.scaleY,n.scaleX=l+(Math.abs(a)*F.signum(l)-l)*o,n.scaleY=u+(Math.abs(h)*F.signum(u)-u)*o;break;case R.add:l=n.scaleX,u=n.scaleY,n.scaleX=l+(Math.abs(a)*F.signum(l)-n.data.scaleX)*o,n.scaleY=u+(Math.abs(h)*F.signum(u)-n.data.scaleY)*o}else switch(m){case R.setup:l=Math.abs(n.data.scaleX)*F.signum(a),u=Math.abs(n.data.scaleY)*F.signum(h),n.scaleX=l+(a-l)*o,n.scaleY=u+(h-u)*o;break;case R.first:case R.replace:l=Math.abs(n.scaleX)*F.signum(a),u=Math.abs(n.scaleY)*F.signum(h),n.scaleX=l+(a-l)*o,n.scaleY=u+(h-u)*o;break;case R.add:l=F.signum(a),u=F.signum(h),n.scaleX=Math.abs(n.scaleX)*l+(a-Math.abs(n.data.scaleX)*l)*o,n.scaleY=Math.abs(n.scaleY)*u+(h-Math.abs(n.data.scaleY)*u)*o}}}},bs=class Nt extends Tt{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,r,s,i,o,m,d){const e=this.frames,n=t.bones[this.boneIndex];if(!n.active)return;if(s<e[0]){switch(m){case R.setup:n.shearX=n.data.shearX,n.shearY=n.data.shearY;return;case R.first:n.shearX+=(n.data.shearX-n.shearX)*o,n.shearY+=(n.data.shearY-n.shearY)*o}return}let a=0,h=0;if(s>=e[e.length-Nt.ENTRIES])a=e[e.length+Nt.PREV_X],h=e[e.length+Nt.PREV_Y];else{const l=ht.binarySearch(e,s,Nt.ENTRIES);a=e[l+Nt.PREV_X],h=e[l+Nt.PREV_Y];const u=e[l],f=this.getCurvePercent(l/Nt.ENTRIES-1,1-(s-u)/(e[l+Nt.PREV_TIME]-u));a=a+(e[l+Nt.X]-a)*f,h=h+(e[l+Nt.Y]-h)*f}switch(m){case R.setup:n.shearX=n.data.shearX+a*o,n.shearY=n.data.shearY+h*o;break;case R.first:case R.replace:n.shearX+=(n.data.shearX+a-n.shearX)*o,n.shearY+=(n.data.shearY+h-n.shearY)*o;break;case R.add:n.shearX+=a*o,n.shearY+=h*o}}};const q=class extends At{constructor(t){super(t),this.frames=C.newFloatArray(t*q.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(t,r,s,i,o,m){t*=q.ENTRIES,this.frames[t]=r,this.frames[t+q.R]=s,this.frames[t+q.G]=i,this.frames[t+q.B]=o,this.frames[t+q.A]=m}apply(t,r,s,i,o,m,d){const e=t.slots[this.slotIndex];if(!e.bone.active)return;const n=this.frames;if(s<n[0]){switch(m){case R.setup:e.color.setFromColor(e.data.color);return;case R.first:const f=e.color,g=e.data.color;f.add((g.r-f.r)*o,(g.g-f.g)*o,(g.b-f.b)*o,(g.a-f.a)*o)}return}let a=0,h=0,l=0,u=0;if(s>=n[n.length-q.ENTRIES]){const f=n.length;a=n[f+q.PREV_R],h=n[f+q.PREV_G],l=n[f+q.PREV_B],u=n[f+q.PREV_A]}else{const f=ht.binarySearch(n,s,q.ENTRIES);a=n[f+q.PREV_R],h=n[f+q.PREV_G],l=n[f+q.PREV_B],u=n[f+q.PREV_A];const g=n[f],w=this.getCurvePercent(f/q.ENTRIES-1,1-(s-g)/(n[f+q.PREV_TIME]-g));a+=(n[f+q.R]-a)*w,h+=(n[f+q.G]-h)*w,l+=(n[f+q.B]-l)*w,u+=(n[f+q.A]-u)*w}if(o==1)e.color.set(a,h,l,u);else{const f=e.color;m==R.setup&&f.setFromColor(e.data.color),f.add((a-f.r)*o,(h-f.g)*o,(l-f.b)*o,(u-f.a)*o)}}};let St=q;St.ENTRIES=5;St.PREV_TIME=-5;St.PREV_R=-4;St.PREV_G=-3;St.PREV_B=-2;St.PREV_A=-1;St.R=1;St.G=2;St.B=3;St.A=4;const O=class extends At{constructor(t){super(t),this.frames=C.newFloatArray(t*O.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(t,r,s,i,o,m,d,e,n){t*=O.ENTRIES,this.frames[t]=r,this.frames[t+O.R]=s,this.frames[t+O.G]=i,this.frames[t+O.B]=o,this.frames[t+O.A]=m,this.frames[t+O.R2]=d,this.frames[t+O.G2]=e,this.frames[t+O.B2]=n}apply(t,r,s,i,o,m,d){const e=t.slots[this.slotIndex];if(!e.bone.active)return;const n=this.frames;if(s<n[0]){switch(m){case R.setup:e.color.setFromColor(e.data.color),e.darkColor.setFromColor(e.data.darkColor);return;case R.first:const E=e.color,x=e.darkColor,p=e.data.color,b=e.data.darkColor;E.add((p.r-E.r)*o,(p.g-E.g)*o,(p.b-E.b)*o,(p.a-E.a)*o),x.add((b.r-x.r)*o,(b.g-x.g)*o,(b.b-x.b)*o,0)}return}let a=0,h=0,l=0,u=0,f=0,g=0,w=0;if(s>=n[n.length-O.ENTRIES]){const E=n.length;a=n[E+O.PREV_R],h=n[E+O.PREV_G],l=n[E+O.PREV_B],u=n[E+O.PREV_A],f=n[E+O.PREV_R2],g=n[E+O.PREV_G2],w=n[E+O.PREV_B2]}else{const E=ht.binarySearch(n,s,O.ENTRIES);a=n[E+O.PREV_R],h=n[E+O.PREV_G],l=n[E+O.PREV_B],u=n[E+O.PREV_A],f=n[E+O.PREV_R2],g=n[E+O.PREV_G2],w=n[E+O.PREV_B2];const x=n[E],p=this.getCurvePercent(E/O.ENTRIES-1,1-(s-x)/(n[E+O.PREV_TIME]-x));a+=(n[E+O.R]-a)*p,h+=(n[E+O.G]-h)*p,l+=(n[E+O.B]-l)*p,u+=(n[E+O.A]-u)*p,f+=(n[E+O.R2]-f)*p,g+=(n[E+O.G2]-g)*p,w+=(n[E+O.B2]-w)*p}if(o==1)e.color.set(a,h,l,u),e.darkColor.set(f,g,w,1);else{const E=e.color,x=e.darkColor;m==R.setup&&(E.setFromColor(e.data.color),x.setFromColor(e.data.darkColor)),E.add((a-E.r)*o,(h-E.g)*o,(l-E.b)*o,(u-E.a)*o),x.add((f-x.r)*o,(g-x.g)*o,(w-x.b)*o,0)}}};let nt=O;nt.ENTRIES=8;nt.PREV_TIME=-8;nt.PREV_R=-7;nt.PREV_G=-6;nt.PREV_B=-5;nt.PREV_A=-4;nt.PREV_R2=-3;nt.PREV_G2=-2;nt.PREV_B2=-1;nt.R=1;nt.G=2;nt.B=3;nt.A=4;nt.R2=5;nt.G2=6;nt.B2=7;let ps=class{constructor(t){this.frames=C.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,r,s){this.frames[t]=r,this.attachmentNames[t]=s}apply(t,r,s,i,o,m,d){const e=t.slots[this.slotIndex];if(!e.bone.active)return;if(d==K.mixOut){m==R.setup&&this.setAttachment(t,e,e.data.attachmentName);return}const n=this.frames;if(s<n[0]){(m==R.setup||m==R.first)&&this.setAttachment(t,e,e.data.attachmentName);return}let a=0;s>=n[n.length-1]?a=n.length-1:a=ht.binarySearch(n,s,1)-1;const h=this.attachmentNames[a];t.slots[this.slotIndex].setAttachment(h==null?null:t.getAttachment(this.slotIndex,h))}setAttachment(t,r,s){r.setAttachment(s==null?null:t.getAttachment(this.slotIndex,s))}},Qe=null,ys=class extends At{constructor(t){super(t),this.frames=C.newFloatArray(t),this.frameVertices=new Array(t),Qe==null&&(Qe=C.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,r,s){this.frames[t]=r,this.frameVertices[t]=s}apply(t,r,s,i,o,m,d){const e=t.slots[this.slotIndex];if(!e.bone.active)return;const n=e.getAttachment();if(!(n instanceof ue)||n.deformAttachment!=this.attachment)return;const a=e.deform;a.length==0&&(m=R.setup);const h=this.frameVertices,l=h[0].length,u=this.frames;if(s<u[0]){const b=n;switch(m){case R.setup:a.length=0;return;case R.first:if(o==1){a.length=0;break}const y=C.setArraySize(a,l);if(b.bones==null){const S=b.vertices;for(let I=0;I<l;I++)y[I]+=(S[I]-y[I])*o}else{o=1-o;for(let S=0;S<l;S++)y[S]*=o}}return}const f=C.setArraySize(a,l);if(s>=u[u.length-1]){const b=h[u.length-1];if(o==1)if(m==R.add){const y=n;if(y.bones==null){const S=y.vertices;for(let I=0;I<l;I++)f[I]+=b[I]-S[I]}else for(let S=0;S<l;S++)f[S]+=b[S]}else C.arrayCopy(b,0,f,0,l);else switch(m){case R.setup:{const S=n;if(S.bones==null){const I=S.vertices;for(let v=0;v<l;v++){const M=I[v];f[v]=M+(b[v]-M)*o}}else for(let I=0;I<l;I++)f[I]=b[I]*o;break}case R.first:case R.replace:for(let S=0;S<l;S++)f[S]+=(b[S]-f[S])*o;break;case R.add:const y=n;if(y.bones==null){const S=y.vertices;for(let I=0;I<l;I++)f[I]+=(b[I]-S[I])*o}else for(let S=0;S<l;S++)f[S]+=b[S]*o}return}const g=ht.binarySearch(u,s),w=h[g-1],E=h[g],x=u[g],p=this.getCurvePercent(g-1,1-(s-x)/(u[g-1]-x));if(o==1)if(m==R.add){const b=n;if(b.bones==null){const y=b.vertices;for(let S=0;S<l;S++){const I=w[S];f[S]+=I+(E[S]-I)*p-y[S]}}else for(let y=0;y<l;y++){const S=w[y];f[y]+=S+(E[y]-S)*p}}else for(let b=0;b<l;b++){const y=w[b];f[b]=y+(E[b]-y)*p}else switch(m){case R.setup:{const y=n;if(y.bones==null){const S=y.vertices;for(let I=0;I<l;I++){const v=w[I],M=S[I];f[I]=M+(v+(E[I]-v)*p-M)*o}}else for(let S=0;S<l;S++){const I=w[S];f[S]=(I+(E[S]-I)*p)*o}break}case R.first:case R.replace:for(let y=0;y<l;y++){const S=w[y];f[y]+=(S+(E[y]-S)*p-f[y])*o}break;case R.add:const b=n;if(b.bones==null){const y=b.vertices;for(let S=0;S<l;S++){const I=w[S];f[S]+=(I+(E[S]-I)*p-y[S])*o}}else for(let y=0;y<l;y++){const S=w[y];f[y]+=(S+(E[y]-S)*p)*o}}}},Ss=class{constructor(t){this.frames=C.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,r){this.frames[t]=r.time,this.events[t]=r}apply(t,r,s,i,o,m,d){if(i==null)return;const e=this.frames,n=this.frames.length;if(r>s)this.apply(t,r,Number.MAX_VALUE,i,o,m,d),r=-1;else if(r>=e[n-1])return;if(s<e[0])return;let a=0;if(r<e[0])a=0;else{a=ht.binarySearch(e,r);const h=e[a];for(;a>0&&e[a-1]==h;)a--}for(;a<n&&s>=e[a];a++)i.push(this.events[a])}},Rs=class{constructor(t){this.frames=C.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,r,s){this.frames[t]=r,this.drawOrders[t]=s}apply(t,r,s,i,o,m,d){const e=t.drawOrder,n=t.slots;if(d==K.mixOut&&m==R.setup){C.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const a=this.frames;if(s<a[0]){(m==R.setup||m==R.first)&&C.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let h=0;s>=a[a.length-1]?h=a.length-1:h=ht.binarySearch(a,s)-1;const l=this.drawOrders[h];if(l==null)C.arrayCopy(n,0,e,0,n.length);else for(let u=0,f=l.length;u<f;u++)e[u]=n[l[u]]}};const D=class extends At{constructor(t){super(t),this.frames=C.newFloatArray(t*D.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(t,r,s,i,o,m,d){t*=D.ENTRIES,this.frames[t]=r,this.frames[t+D.MIX]=s,this.frames[t+D.SOFTNESS]=i,this.frames[t+D.BEND_DIRECTION]=o,this.frames[t+D.COMPRESS]=m?1:0,this.frames[t+D.STRETCH]=d?1:0}apply(t,r,s,i,o,m,d){const e=this.frames,n=t.ikConstraints[this.ikConstraintIndex];if(!n.active)return;if(s<e[0]){switch(m){case R.setup:n.mix=n.data.mix,n.softness=n.data.softness,n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch;return;case R.first:n.mix+=(n.data.mix-n.mix)*o,n.softness+=(n.data.softness-n.softness)*o,n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch}return}if(s>=e[e.length-D.ENTRIES]){m==R.setup?(n.mix=n.data.mix+(e[e.length+D.PREV_MIX]-n.data.mix)*o,n.softness=n.data.softness+(e[e.length+D.PREV_SOFTNESS]-n.data.softness)*o,d==K.mixOut?(n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch):(n.bendDirection=e[e.length+D.PREV_BEND_DIRECTION],n.compress=e[e.length+D.PREV_COMPRESS]!=0,n.stretch=e[e.length+D.PREV_STRETCH]!=0)):(n.mix+=(e[e.length+D.PREV_MIX]-n.mix)*o,n.softness+=(e[e.length+D.PREV_SOFTNESS]-n.softness)*o,d==K.mixIn&&(n.bendDirection=e[e.length+D.PREV_BEND_DIRECTION],n.compress=e[e.length+D.PREV_COMPRESS]!=0,n.stretch=e[e.length+D.PREV_STRETCH]!=0));return}const a=ht.binarySearch(e,s,D.ENTRIES),h=e[a+D.PREV_MIX],l=e[a+D.PREV_SOFTNESS],u=e[a],f=this.getCurvePercent(a/D.ENTRIES-1,1-(s-u)/(e[a+D.PREV_TIME]-u));m==R.setup?(n.mix=n.data.mix+(h+(e[a+D.MIX]-h)*f-n.data.mix)*o,n.softness=n.data.softness+(l+(e[a+D.SOFTNESS]-l)*f-n.data.softness)*o,d==K.mixOut?(n.bendDirection=n.data.bendDirection,n.compress=n.data.compress,n.stretch=n.data.stretch):(n.bendDirection=e[a+D.PREV_BEND_DIRECTION],n.compress=e[a+D.PREV_COMPRESS]!=0,n.stretch=e[a+D.PREV_STRETCH]!=0)):(n.mix+=(h+(e[a+D.MIX]-h)*f-n.mix)*o,n.softness+=(l+(e[a+D.SOFTNESS]-l)*f-n.softness)*o,d==K.mixIn&&(n.bendDirection=e[a+D.PREV_BEND_DIRECTION],n.compress=e[a+D.PREV_COMPRESS]!=0,n.stretch=e[a+D.PREV_STRETCH]!=0))}};let mt=D;mt.ENTRIES=6;mt.PREV_TIME=-6;mt.PREV_MIX=-5;mt.PREV_SOFTNESS=-4;mt.PREV_BEND_DIRECTION=-3;mt.PREV_COMPRESS=-2;mt.PREV_STRETCH=-1;mt.MIX=1;mt.SOFTNESS=2;mt.BEND_DIRECTION=3;mt.COMPRESS=4;mt.STRETCH=5;const W=class extends At{constructor(t){super(t),this.frames=C.newFloatArray(t*W.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(t,r,s,i,o,m){t*=W.ENTRIES,this.frames[t]=r,this.frames[t+W.ROTATE]=s,this.frames[t+W.TRANSLATE]=i,this.frames[t+W.SCALE]=o,this.frames[t+W.SHEAR]=m}apply(t,r,s,i,o,m,d){const e=this.frames,n=t.transformConstraints[this.transformConstraintIndex];if(!n.active)return;if(s<e[0]){const f=n.data;switch(m){case R.setup:n.rotateMix=f.rotateMix,n.translateMix=f.translateMix,n.scaleMix=f.scaleMix,n.shearMix=f.shearMix;return;case R.first:n.rotateMix+=(f.rotateMix-n.rotateMix)*o,n.translateMix+=(f.translateMix-n.translateMix)*o,n.scaleMix+=(f.scaleMix-n.scaleMix)*o,n.shearMix+=(f.shearMix-n.shearMix)*o}return}let a=0,h=0,l=0,u=0;if(s>=e[e.length-W.ENTRIES]){const f=e.length;a=e[f+W.PREV_ROTATE],h=e[f+W.PREV_TRANSLATE],l=e[f+W.PREV_SCALE],u=e[f+W.PREV_SHEAR]}else{const f=ht.binarySearch(e,s,W.ENTRIES);a=e[f+W.PREV_ROTATE],h=e[f+W.PREV_TRANSLATE],l=e[f+W.PREV_SCALE],u=e[f+W.PREV_SHEAR];const g=e[f],w=this.getCurvePercent(f/W.ENTRIES-1,1-(s-g)/(e[f+W.PREV_TIME]-g));a+=(e[f+W.ROTATE]-a)*w,h+=(e[f+W.TRANSLATE]-h)*w,l+=(e[f+W.SCALE]-l)*w,u+=(e[f+W.SHEAR]-u)*w}if(m==R.setup){const f=n.data;n.rotateMix=f.rotateMix+(a-f.rotateMix)*o,n.translateMix=f.translateMix+(h-f.translateMix)*o,n.scaleMix=f.scaleMix+(l-f.scaleMix)*o,n.shearMix=f.shearMix+(u-f.shearMix)*o}else n.rotateMix+=(a-n.rotateMix)*o,n.translateMix+=(h-n.translateMix)*o,n.scaleMix+=(l-n.scaleMix)*o,n.shearMix+=(u-n.shearMix)*o}};let Rt=W;Rt.ENTRIES=5;Rt.PREV_TIME=-5;Rt.PREV_ROTATE=-4;Rt.PREV_TRANSLATE=-3;Rt.PREV_SCALE=-2;Rt.PREV_SHEAR=-1;Rt.ROTATE=1;Rt.TRANSLATE=2;Rt.SCALE=3;Rt.SHEAR=4;const Yt=class extends At{constructor(t){super(t),this.frames=C.newFloatArray(t*Yt.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(t,r,s){t*=Yt.ENTRIES,this.frames[t]=r,this.frames[t+Yt.VALUE]=s}apply(t,r,s,i,o,m,d){const e=this.frames,n=t.pathConstraints[this.pathConstraintIndex];if(!n.active)return;if(s<e[0]){switch(m){case R.setup:n.position=n.data.position;return;case R.first:n.position+=(n.data.position-n.position)*o}return}let a=0;if(s>=e[e.length-Yt.ENTRIES])a=e[e.length+Yt.PREV_VALUE];else{const h=ht.binarySearch(e,s,Yt.ENTRIES);a=e[h+Yt.PREV_VALUE];const l=e[h],u=this.getCurvePercent(h/Yt.ENTRIES-1,1-(s-l)/(e[h+Yt.PREV_TIME]-l));a+=(e[h+Yt.VALUE]-a)*u}m==R.setup?n.position=n.data.position+(a-n.data.position)*o:n.position+=(a-n.position)*o}};let jt=Yt;jt.ENTRIES=2;jt.PREV_TIME=-2;jt.PREV_VALUE=-1;jt.VALUE=1;let Is=class Qt extends jt{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,r,s,i,o,m,d){const e=this.frames,n=t.pathConstraints[this.pathConstraintIndex];if(!n.active)return;if(s<e[0]){switch(m){case R.setup:n.spacing=n.data.spacing;return;case R.first:n.spacing+=(n.data.spacing-n.spacing)*o}return}let a=0;if(s>=e[e.length-Qt.ENTRIES])a=e[e.length+Qt.PREV_VALUE];else{const h=ht.binarySearch(e,s,Qt.ENTRIES);a=e[h+Qt.PREV_VALUE];const l=e[h],u=this.getCurvePercent(h/Qt.ENTRIES-1,1-(s-l)/(e[h+Qt.PREV_TIME]-l));a+=(e[h+Qt.VALUE]-a)*u}m==R.setup?n.spacing=n.data.spacing+(a-n.data.spacing)*o:n.spacing+=(a-n.spacing)*o}};const xt=class extends At{constructor(t){super(t),this.frames=C.newFloatArray(t*xt.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(t,r,s,i){t*=xt.ENTRIES,this.frames[t]=r,this.frames[t+xt.ROTATE]=s,this.frames[t+xt.TRANSLATE]=i}apply(t,r,s,i,o,m,d){const e=this.frames,n=t.pathConstraints[this.pathConstraintIndex];if(!n.active)return;if(s<e[0]){switch(m){case R.setup:n.rotateMix=n.data.rotateMix,n.translateMix=n.data.translateMix;return;case R.first:n.rotateMix+=(n.data.rotateMix-n.rotateMix)*o,n.translateMix+=(n.data.translateMix-n.translateMix)*o}return}let a=0,h=0;if(s>=e[e.length-xt.ENTRIES])a=e[e.length+xt.PREV_ROTATE],h=e[e.length+xt.PREV_TRANSLATE];else{const l=ht.binarySearch(e,s,xt.ENTRIES);a=e[l+xt.PREV_ROTATE],h=e[l+xt.PREV_TRANSLATE];const u=e[l],f=this.getCurvePercent(l/xt.ENTRIES-1,1-(s-u)/(e[l+xt.PREV_TIME]-u));a+=(e[l+xt.ROTATE]-a)*f,h+=(e[l+xt.TRANSLATE]-h)*f}m==R.setup?(n.rotateMix=n.data.rotateMix+(a-n.data.rotateMix)*o,n.translateMix=n.data.translateMix+(h-n.data.translateMix)*o):(n.rotateMix+=(a-n.rotateMix)*o,n.translateMix+=(h-n.translateMix)*o)}};let Ut=xt;Ut.ENTRIES=3;Ut.PREV_TIME=-3;Ut.PREV_ROTATE=-2;Ut.PREV_TRANSLATE=-1;Ut.ROTATE=1;Ut.TRANSLATE=2;new ht("<empty>",[],0);let As=class{constructor(t){this.atlas=t}newRegionAttachment(t,r,s){const i=this.atlas.findRegion(s);if(i==null)throw new Error(`Region not found in atlas: ${s} (region attachment: ${r})`);const o=new Y(r);return o.region=i,o}newMeshAttachment(t,r,s){const i=this.atlas.findRegion(s);if(i==null)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${r})`);const o=new gs(r);return o.region=i,o}newBoundingBoxAttachment(t,r){return new Dn(r)}newPathAttachment(t,r){return new zn(r)}newPointAttachment(t,r){return new Gn(r)}newClippingAttachment(t,r){return new Un(r)}},Cs=class{constructor(t,r,s){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=st.Normal,this.skinRequired=!1,this.color=new T,t<0)throw new Error("index must be >= 0.");if(r==null)throw new Error("name cannot be null.");this.index=t,this.name=r,this.parent=s}},Be=class{constructor(t,r,s){this.name=t,this.order=r,this.skinRequired=s}},vs=class{constructor(t,r){if(r==null)throw new Error("data cannot be null.");this.time=t,this.data=r}},Ts=class{constructor(t){this.name=t}},Ms=class extends Be{constructor(t){super(t,0,!1),this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}},Vs=class extends Be{constructor(t){super(t,0,!1),this.bones=new Array}};var pt=(c=>(c[c.Length=0]="Length",c[c.Fixed=1]="Fixed",c[c.Percent=2]="Percent",c))(pt||{});let Fs=class{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const r=this.bones;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const r=this.bones;for(let s=0,i=r.length;s<i;s++)if(r[s].name==t)return s;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const r=this.slots;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const r=this.slots;for(let s=0,i=r.length;s<i;s++)if(r[s].name==t)return s;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const r=this.skins;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const r=this.events;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const r=this.animations;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const r=this.ikConstraints;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const r=this.transformConstraints;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const r=this.pathConstraints;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const r=this.pathConstraints;for(let s=0,i=r.length;s<i;s++)if(r[s].name==t)return s;return-1}},Ps=class{constructor(t,r,s){if(this.color=new T(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(r==null)throw new Error("name cannot be null.");if(s==null)throw new Error("boneData cannot be null.");this.index=t,this.name=r,this.boneData=s}},ks=class extends Be{constructor(t){super(t,0,!1),this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}},ts=class{constructor(t,r,s){this.slotIndex=t,this.name=r,this.attachment=s}},Ne=class{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,t==null)throw new Error("name cannot be null.");this.name=t}setAttachment(t,r,s){if(s==null)throw new Error("attachment cannot be null.");const i=this.attachments;t>=i.length&&(i.length=t+1),i[t]||(i[t]={}),i[t][r]=s}addSkin(t){for(let s=0;s<t.bones.length;s++){const i=t.bones[s];let o=!1;for(let m=0;m<this.bones.length;m++)if(this.bones[m]==i){o=!0;break}o||this.bones.push(i)}for(let s=0;s<t.constraints.length;s++){const i=t.constraints[s];let o=!1;for(let m=0;m<this.constraints.length;m++)if(this.constraints[m]==i){o=!0;break}o||this.constraints.push(i)}const r=t.getAttachments();for(let s=0;s<r.length;s++){const i=r[s];this.setAttachment(i.slotIndex,i.name,i.attachment)}}copySkin(t){for(let s=0;s<t.bones.length;s++){const i=t.bones[s];let o=!1;for(let m=0;m<this.bones.length;m++)if(this.bones[m]==i){o=!0;break}o||this.bones.push(i)}for(let s=0;s<t.constraints.length;s++){const i=t.constraints[s];let o=!1;for(let m=0;m<this.constraints.length;m++)if(this.constraints[m]==i){o=!0;break}o||this.constraints.push(i)}const r=t.getAttachments();for(let s=0;s<r.length;s++){const i=r[s];i.attachment!=null&&(i.attachment instanceof gs?(i.attachment=i.attachment.newLinkedMesh(),this.setAttachment(i.slotIndex,i.name,i.attachment)):(i.attachment=i.attachment.copy(),this.setAttachment(i.slotIndex,i.name,i.attachment)))}}getAttachment(t,r){const s=this.attachments[t];return s?s[r]:null}removeAttachment(t,r){const s=this.attachments[t];s&&(s[r]=null)}getAttachments(){const t=new Array;for(let r=0;r<this.attachments.length;r++){const s=this.attachments[r];if(s)for(const i in s){const o=s[i];o&&t.push(new ts(r,i,o))}}return t}getAttachmentsForSlot(t,r){const s=this.attachments[t];if(s)for(const i in s){const o=s[i];o&&r.push(new ts(t,i,o))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,r){let s=0;for(let i=0;i<t.slots.length;i++){const o=t.slots[i],m=o.getAttachment();if(m&&s<r.attachments.length){const d=r.attachments[s];for(const e in d){const n=d[e];if(m==n){const a=this.getAttachment(s,e);a!=null&&o.setAttachment(a);break}}}s++}}};const J=class{constructor(c){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=c}readSkeletonData(c){const t=this.scale,r=new Fs;r.name="";const s=new Ce(c);r.hash=s.readString(),r.version=s.readString(),r.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),r.x=s.readFloat(),r.y=s.readFloat(),r.width=s.readFloat(),r.height=s.readFloat();const i=s.readBoolean();i&&(r.fps=s.readFloat(),r.imagesPath=s.readString(),r.audioPath=s.readString());let o=0;o=s.readInt(!0);for(let d=0;d<o;d++)s.strings.push(s.readString());o=s.readInt(!0);for(let d=0;d<o;d++){const e=s.readString(),n=d==0?null:r.bones[s.readInt(!0)],a=new Cs(d,e,n);a.rotation=s.readFloat(),a.x=s.readFloat()*t,a.y=s.readFloat()*t,a.scaleX=s.readFloat(),a.scaleY=s.readFloat(),a.shearX=s.readFloat(),a.shearY=s.readFloat(),a.length=s.readFloat()*t,a.transformMode=J.TransformModeValues[s.readInt(!0)],a.skinRequired=s.readBoolean(),i&&T.rgba8888ToColor(a.color,s.readInt32()),r.bones.push(a)}o=s.readInt(!0);for(let d=0;d<o;d++){const e=s.readString(),n=r.bones[s.readInt(!0)],a=new Ps(d,e,n);T.rgba8888ToColor(a.color,s.readInt32());const h=s.readInt32();h!=-1&&T.rgb888ToColor(a.darkColor=new T,h),a.attachmentName=s.readStringRef(),a.blendMode=J.BlendModeValues[s.readInt(!0)],r.slots.push(a)}o=s.readInt(!0);for(let d=0,e;d<o;d++){const n=new Ms(s.readString());n.order=s.readInt(!0),n.skinRequired=s.readBoolean(),e=s.readInt(!0);for(let a=0;a<e;a++)n.bones.push(r.bones[s.readInt(!0)]);n.target=r.bones[s.readInt(!0)],n.mix=s.readFloat(),n.softness=s.readFloat()*t,n.bendDirection=s.readByte(),n.compress=s.readBoolean(),n.stretch=s.readBoolean(),n.uniform=s.readBoolean(),r.ikConstraints.push(n)}o=s.readInt(!0);for(let d=0,e;d<o;d++){const n=new ks(s.readString());n.order=s.readInt(!0),n.skinRequired=s.readBoolean(),e=s.readInt(!0);for(let a=0;a<e;a++)n.bones.push(r.bones[s.readInt(!0)]);n.target=r.bones[s.readInt(!0)],n.local=s.readBoolean(),n.relative=s.readBoolean(),n.offsetRotation=s.readFloat(),n.offsetX=s.readFloat()*t,n.offsetY=s.readFloat()*t,n.offsetScaleX=s.readFloat(),n.offsetScaleY=s.readFloat(),n.offsetShearY=s.readFloat(),n.rotateMix=s.readFloat(),n.translateMix=s.readFloat(),n.scaleMix=s.readFloat(),n.shearMix=s.readFloat(),r.transformConstraints.push(n)}o=s.readInt(!0);for(let d=0,e;d<o;d++){const n=new Vs(s.readString());n.order=s.readInt(!0),n.skinRequired=s.readBoolean(),e=s.readInt(!0);for(let a=0;a<e;a++)n.bones.push(r.bones[s.readInt(!0)]);n.target=r.slots[s.readInt(!0)],n.positionMode=J.PositionModeValues[s.readInt(!0)],n.spacingMode=J.SpacingModeValues[s.readInt(!0)],n.rotateMode=J.RotateModeValues[s.readInt(!0)],n.offsetRotation=s.readFloat(),n.position=s.readFloat(),n.positionMode==at.Fixed&&(n.position*=t),n.spacing=s.readFloat(),(n.spacingMode==pt.Length||n.spacingMode==pt.Fixed)&&(n.spacing*=t),n.rotateMix=s.readFloat(),n.translateMix=s.readFloat(),r.pathConstraints.push(n)}const m=this.readSkin(s,r,!0,i);m!=null&&(r.defaultSkin=m,r.skins.push(m));{let d=r.skins.length;for(C.setArraySize(r.skins,o=d+s.readInt(!0));d<o;d++)r.skins[d]=this.readSkin(s,r,!1,i)}o=this.linkedMeshes.length;for(let d=0;d<o;d++){const e=this.linkedMeshes[d],n=e.skin==null?r.defaultSkin:r.findSkin(e.skin);if(n==null)throw new Error(`Skin not found: ${e.skin}`);const a=n.getAttachment(e.slotIndex,e.parent);if(a==null)throw new Error(`Parent mesh not found: ${e.parent}`);e.mesh.deformAttachment=e.inheritDeform?a:e.mesh,e.mesh.setParentMesh(a)}this.linkedMeshes.length=0,o=s.readInt(!0);for(let d=0;d<o;d++){const e=new Ts(s.readStringRef());e.intValue=s.readInt(!1),e.floatValue=s.readFloat(),e.stringValue=s.readString(),e.audioPath=s.readString(),e.audioPath!=null&&(e.volume=s.readFloat(),e.balance=s.readFloat()),r.events.push(e)}o=s.readInt(!0);for(let d=0;d<o;d++)r.animations.push(this.readAnimation(s,s.readString(),r));return r}readSkin(c,t,r,s){let i=null,o=0;if(r){if(o=c.readInt(!0),o==0)return null;i=new Ne("default")}else{i=new Ne(c.readStringRef()),i.bones.length=c.readInt(!0);for(let m=0,d=i.bones.length;m<d;m++)i.bones[m]=t.bones[c.readInt(!0)];for(let m=0,d=c.readInt(!0);m<d;m++)i.constraints.push(t.ikConstraints[c.readInt(!0)]);for(let m=0,d=c.readInt(!0);m<d;m++)i.constraints.push(t.transformConstraints[c.readInt(!0)]);for(let m=0,d=c.readInt(!0);m<d;m++)i.constraints.push(t.pathConstraints[c.readInt(!0)]);o=c.readInt(!0)}for(let m=0;m<o;m++){const d=c.readInt(!0);for(let e=0,n=c.readInt(!0);e<n;e++){const a=c.readStringRef(),h=this.readAttachment(c,t,i,d,a,s);h!=null&&i.setAttachment(d,a,h)}}return i}readAttachment(c,t,r,s,i,o){const m=this.scale;let d=c.readStringRef();d==null&&(d=i);const e=c.readByte();switch(J.AttachmentTypeValues[e]){case B.Region:{let a=c.readStringRef();const h=c.readFloat(),l=c.readFloat(),u=c.readFloat(),f=c.readFloat(),g=c.readFloat(),w=c.readFloat(),E=c.readFloat(),x=c.readInt32();a==null&&(a=d);const p=this.attachmentLoader.newRegionAttachment(r,d,a);return p==null?null:(p.path=a,p.x=l*m,p.y=u*m,p.scaleX=f,p.scaleY=g,p.rotation=h,p.width=w*m,p.height=E*m,T.rgba8888ToColor(p.color,x),p)}case B.BoundingBox:{const a=c.readInt(!0),h=this.readVertices(c,a),l=o?c.readInt32():0,u=this.attachmentLoader.newBoundingBoxAttachment(r,d);return u==null?null:(u.worldVerticesLength=a<<1,u.vertices=h.vertices,u.bones=h.bones,o&&T.rgba8888ToColor(u.color,l),u)}case B.Mesh:{let a=c.readStringRef();const h=c.readInt32(),l=c.readInt(!0),u=this.readFloatArray(c,l<<1,1),f=this.readShortArray(c),g=this.readVertices(c,l),w=c.readInt(!0);let E=null,x=0,p=0;o&&(E=this.readShortArray(c),x=c.readFloat(),p=c.readFloat()),a==null&&(a=d);const b=this.attachmentLoader.newMeshAttachment(r,d,a);return b==null?null:(b.path=a,T.rgba8888ToColor(b.color,h),b.bones=g.bones,b.vertices=g.vertices,b.worldVerticesLength=l<<1,b.triangles=f,b.regionUVs=new Float32Array(u),b.hullLength=w<<1,o&&(b.edges=E,b.width=x*m,b.height=p*m),b)}case B.LinkedMesh:{let a=c.readStringRef();const h=c.readInt32(),l=c.readStringRef(),u=c.readStringRef(),f=c.readBoolean();let g=0,w=0;o&&(g=c.readFloat(),w=c.readFloat()),a==null&&(a=d);const E=this.attachmentLoader.newMeshAttachment(r,d,a);return E==null?null:(E.path=a,T.rgba8888ToColor(E.color,h),o&&(E.width=g*m,E.height=w*m),this.linkedMeshes.push(new qn(E,l,s,u,f)),E)}case B.Path:{const a=c.readBoolean(),h=c.readBoolean(),l=c.readInt(!0),u=this.readVertices(c,l),f=C.newArray(l/3,0);for(let E=0,x=f.length;E<x;E++)f[E]=c.readFloat()*m;const g=o?c.readInt32():0,w=this.attachmentLoader.newPathAttachment(r,d);return w==null?null:(w.closed=a,w.constantSpeed=h,w.worldVerticesLength=l<<1,w.vertices=u.vertices,w.bones=u.bones,w.lengths=f,o&&T.rgba8888ToColor(w.color,g),w)}case B.Point:{const a=c.readFloat(),h=c.readFloat(),l=c.readFloat(),u=o?c.readInt32():0,f=this.attachmentLoader.newPointAttachment(r,d);return f==null?null:(f.x=h*m,f.y=l*m,f.rotation=a,o&&T.rgba8888ToColor(f.color,u),f)}case B.Clipping:{const a=c.readInt(!0),h=c.readInt(!0),l=this.readVertices(c,h),u=o?c.readInt32():0,f=this.attachmentLoader.newClippingAttachment(r,d);return f==null?null:(f.endSlot=t.slots[a],f.worldVerticesLength=h<<1,f.vertices=l.vertices,f.bones=l.bones,o&&T.rgba8888ToColor(f.color,u),f)}}return null}readVertices(c,t){const r=t<<1,s=new Wn,i=this.scale;if(!c.readBoolean())return s.vertices=this.readFloatArray(c,r,i),s;const o=new Array,m=new Array;for(let d=0;d<t;d++){const e=c.readInt(!0);m.push(e);for(let n=0;n<e;n++)m.push(c.readInt(!0)),o.push(c.readFloat()*i),o.push(c.readFloat()*i),o.push(c.readFloat())}return s.vertices=C.toFloatArray(o),s.bones=m,s}readFloatArray(c,t,r){const s=new Array(t);if(r==1)for(let i=0;i<t;i++)s[i]=c.readFloat();else for(let i=0;i<t;i++)s[i]=c.readFloat()*r;return s}readShortArray(c){const t=c.readInt(!0),r=new Array(t);for(let s=0;s<t;s++)r[s]=c.readShort();return r}readAnimation(c,t,r){const s=new Array,i=this.scale;let o=0;const m=new T,d=new T;for(let a=0,h=c.readInt(!0);a<h;a++){const l=c.readInt(!0);for(let u=0,f=c.readInt(!0);u<f;u++){const g=c.readByte(),w=c.readInt(!0);switch(g){case J.SLOT_ATTACHMENT:{const E=new ps(w);E.slotIndex=l;for(let x=0;x<w;x++)E.setFrame(x,c.readFloat(),c.readStringRef());s.push(E),o=Math.max(o,E.frames[w-1]);break}case J.SLOT_COLOR:{const E=new St(w);E.slotIndex=l;for(let x=0;x<w;x++){const p=c.readFloat();T.rgba8888ToColor(m,c.readInt32()),E.setFrame(x,p,m.r,m.g,m.b,m.a),x<w-1&&this.readCurve(c,x,E)}s.push(E),o=Math.max(o,E.frames[(w-1)*St.ENTRIES]);break}case J.SLOT_TWO_COLOR:{const E=new nt(w);E.slotIndex=l;for(let x=0;x<w;x++){const p=c.readFloat();T.rgba8888ToColor(m,c.readInt32()),T.rgb888ToColor(d,c.readInt32()),E.setFrame(x,p,m.r,m.g,m.b,m.a,d.r,d.g,d.b),x<w-1&&this.readCurve(c,x,E)}s.push(E),o=Math.max(o,E.frames[(w-1)*nt.ENTRIES]);break}}}}for(let a=0,h=c.readInt(!0);a<h;a++){const l=c.readInt(!0);for(let u=0,f=c.readInt(!0);u<f;u++){const g=c.readByte(),w=c.readInt(!0);switch(g){case J.BONE_ROTATE:{const E=new oe(w);E.boneIndex=l;for(let x=0;x<w;x++)E.setFrame(x,c.readFloat(),c.readFloat()),x<w-1&&this.readCurve(c,x,E);s.push(E),o=Math.max(o,E.frames[(w-1)*oe.ENTRIES]);break}case J.BONE_TRANSLATE:case J.BONE_SCALE:case J.BONE_SHEAR:{let E,x=1;g==J.BONE_SCALE?E=new Es(w):g==J.BONE_SHEAR?E=new bs(w):(E=new Tt(w),x=i),E.boneIndex=l;for(let p=0;p<w;p++)E.setFrame(p,c.readFloat(),c.readFloat()*x,c.readFloat()*x),p<w-1&&this.readCurve(c,p,E);s.push(E),o=Math.max(o,E.frames[(w-1)*Tt.ENTRIES]);break}}}}for(let a=0,h=c.readInt(!0);a<h;a++){const l=c.readInt(!0),u=c.readInt(!0),f=new mt(u);f.ikConstraintIndex=l;for(let g=0;g<u;g++)f.setFrame(g,c.readFloat(),c.readFloat(),c.readFloat()*i,c.readByte(),c.readBoolean(),c.readBoolean()),g<u-1&&this.readCurve(c,g,f);s.push(f),o=Math.max(o,f.frames[(u-1)*mt.ENTRIES])}for(let a=0,h=c.readInt(!0);a<h;a++){const l=c.readInt(!0),u=c.readInt(!0),f=new Rt(u);f.transformConstraintIndex=l;for(let g=0;g<u;g++)f.setFrame(g,c.readFloat(),c.readFloat(),c.readFloat(),c.readFloat(),c.readFloat()),g<u-1&&this.readCurve(c,g,f);s.push(f),o=Math.max(o,f.frames[(u-1)*Rt.ENTRIES])}for(let a=0,h=c.readInt(!0);a<h;a++){const l=c.readInt(!0),u=r.pathConstraints[l];for(let f=0,g=c.readInt(!0);f<g;f++){const w=c.readByte(),E=c.readInt(!0);switch(w){case J.PATH_POSITION:case J.PATH_SPACING:{let x,p=1;w==J.PATH_SPACING?(x=new Is(E),(u.spacingMode==pt.Length||u.spacingMode==pt.Fixed)&&(p=i)):(x=new jt(E),u.positionMode==at.Fixed&&(p=i)),x.pathConstraintIndex=l;for(let b=0;b<E;b++)x.setFrame(b,c.readFloat(),c.readFloat()*p),b<E-1&&this.readCurve(c,b,x);s.push(x),o=Math.max(o,x.frames[(E-1)*jt.ENTRIES]);break}case J.PATH_MIX:{const x=new Ut(E);x.pathConstraintIndex=l;for(let p=0;p<E;p++)x.setFrame(p,c.readFloat(),c.readFloat(),c.readFloat()),p<E-1&&this.readCurve(c,p,x);s.push(x),o=Math.max(o,x.frames[(E-1)*Ut.ENTRIES]);break}}}}for(let a=0,h=c.readInt(!0);a<h;a++){const l=r.skins[c.readInt(!0)];for(let u=0,f=c.readInt(!0);u<f;u++){const g=c.readInt(!0);for(let w=0,E=c.readInt(!0);w<E;w++){const x=l.getAttachment(g,c.readStringRef()),p=x.bones!=null,b=x.vertices,y=p?b.length/3*2:b.length,S=c.readInt(!0),I=new ys(S);I.slotIndex=g,I.attachment=x;for(let v=0;v<S;v++){const M=c.readFloat();let P,V=c.readInt(!0);if(V==0)P=p?C.newFloatArray(y):b;else{P=C.newFloatArray(y);const k=c.readInt(!0);if(V+=k,i==1)for(let N=k;N<V;N++)P[N]=c.readFloat();else for(let N=k;N<V;N++)P[N]=c.readFloat()*i;if(!p)for(let N=0,H=P.length;N<H;N++)P[N]+=b[N]}I.setFrame(v,M,P),v<S-1&&this.readCurve(c,v,I)}s.push(I),o=Math.max(o,I.frames[S-1])}}}const e=c.readInt(!0);if(e>0){const a=new Rs(e),h=r.slots.length;for(let l=0;l<e;l++){const u=c.readFloat(),f=c.readInt(!0),g=C.newArray(h,0);for(let p=h-1;p>=0;p--)g[p]=-1;const w=C.newArray(h-f,0);let E=0,x=0;for(let p=0;p<f;p++){const b=c.readInt(!0);for(;E!=b;)w[x++]=E++;g[E+c.readInt(!0)]=E++}for(;E<h;)w[x++]=E++;for(let p=h-1;p>=0;p--)g[p]==-1&&(g[p]=w[--x]);a.setFrame(l,u,g)}s.push(a),o=Math.max(o,a.frames[e-1])}const n=c.readInt(!0);if(n>0){const a=new Ss(n);for(let h=0;h<n;h++){const l=c.readFloat(),u=r.events[c.readInt(!0)],f=new vs(l,u);f.intValue=c.readInt(!1),f.floatValue=c.readFloat(),f.stringValue=c.readBoolean()?c.readString():u.stringValue,f.data.audioPath!=null&&(f.volume=c.readFloat(),f.balance=c.readFloat()),a.setFrame(h,f)}s.push(a),o=Math.max(o,a.frames[n-1])}return new ht(t,s,o)}readCurve(c,t,r){switch(c.readByte()){case J.CURVE_STEPPED:r.setStepped(t);break;case J.CURVE_BEZIER:this.setCurve(r,t,c.readFloat(),c.readFloat(),c.readFloat(),c.readFloat());break}}setCurve(c,t,r,s,i,o){c.setCurve(t,r,s,i,o)}};let ot=J;ot.AttachmentTypeValues=[0,1,2,3,4,5,6];ot.TransformModeValues=[st.Normal,st.OnlyTranslation,st.NoRotationOrReflection,st.NoScale,st.NoScaleOrReflection];ot.PositionModeValues=[at.Fixed,at.Percent];ot.SpacingModeValues=[pt.Length,pt.Fixed,pt.Percent];ot.RotateModeValues=[vt.Tangent,vt.Chain,vt.ChainScale];ot.BlendModeValues=[et.NORMAL,et.ADD,et.MULTIPLY,et.SCREEN];ot.BONE_ROTATE=0;ot.BONE_TRANSLATE=1;ot.BONE_SCALE=2;ot.BONE_SHEAR=3;ot.SLOT_ATTACHMENT=0;ot.SLOT_COLOR=1;ot.SLOT_TWO_COLOR=2;ot.PATH_POSITION=0;ot.PATH_SPACING=1;ot.PATH_MIX=2;ot.CURVE_LINEAR=0;ot.CURVE_STEPPED=1;ot.CURVE_BEZIER=2;let qn=class{constructor(t,r,s,i,o){this.mesh=t,this.skin=r,this.slotIndex=s,this.parent=i,this.inheritDeform=o}},Wn=class{constructor(t=null,r=null){this.bones=t,this.vertices=r}},Zn=class ge{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const r=this.scale,s=new Fs,i=typeof t=="string"?JSON.parse(t):t,o=i.skeleton;if(o!=null){if(s.hash=o.hash,s.version=o.spine,s.version.substr(0,3)!=="3.8"){const m=`Spine 3.8 loader cant load version ${o.spine}. Please configure your pixi-spine bundle`;console.error(m)}s.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),s.x=o.x,s.y=o.y,s.width=o.width,s.height=o.height,s.fps=o.fps,s.imagesPath=o.images}if(i.bones)for(let m=0;m<i.bones.length;m++){const d=i.bones[m];let e=null;const n=this.getValue(d,"parent",null);if(n!=null&&(e=s.findBone(n),e==null))throw new Error(`Parent bone not found: ${n}`);const a=new Cs(s.bones.length,d.name,e);a.length=this.getValue(d,"length",0)*r,a.x=this.getValue(d,"x",0)*r,a.y=this.getValue(d,"y",0)*r,a.rotation=this.getValue(d,"rotation",0),a.scaleX=this.getValue(d,"scaleX",1),a.scaleY=this.getValue(d,"scaleY",1),a.shearX=this.getValue(d,"shearX",0),a.shearY=this.getValue(d,"shearY",0),a.transformMode=ge.transformModeFromString(this.getValue(d,"transform","normal")),a.skinRequired=this.getValue(d,"skin",!1),s.bones.push(a)}if(i.slots)for(let m=0;m<i.slots.length;m++){const d=i.slots[m],e=d.name,n=d.bone,a=s.findBone(n);if(a==null)throw new Error(`Slot bone not found: ${n}`);const h=new Ps(s.slots.length,e,a),l=this.getValue(d,"color",null);l!=null&&h.color.setFromString(l);const u=this.getValue(d,"dark",null);u!=null&&(h.darkColor=new T(1,1,1,1),h.darkColor.setFromString(u)),h.attachmentName=this.getValue(d,"attachment",null),h.blendMode=ge.blendModeFromString(this.getValue(d,"blend","normal")),s.slots.push(h)}if(i.ik)for(let m=0;m<i.ik.length;m++){const d=i.ik[m],e=new Ms(d.name);e.order=this.getValue(d,"order",0),e.skinRequired=this.getValue(d,"skin",!1);for(let a=0;a<d.bones.length;a++){const h=d.bones[a],l=s.findBone(h);if(l==null)throw new Error(`IK bone not found: ${h}`);e.bones.push(l)}const n=d.target;if(e.target=s.findBone(n),e.target==null)throw new Error(`IK target bone not found: ${n}`);e.mix=this.getValue(d,"mix",1),e.softness=this.getValue(d,"softness",0)*r,e.bendDirection=this.getValue(d,"bendPositive",!0)?1:-1,e.compress=this.getValue(d,"compress",!1),e.stretch=this.getValue(d,"stretch",!1),e.uniform=this.getValue(d,"uniform",!1),s.ikConstraints.push(e)}if(i.transform)for(let m=0;m<i.transform.length;m++){const d=i.transform[m],e=new ks(d.name);e.order=this.getValue(d,"order",0),e.skinRequired=this.getValue(d,"skin",!1);for(let a=0;a<d.bones.length;a++){const h=d.bones[a],l=s.findBone(h);if(l==null)throw new Error(`Transform constraint bone not found: ${h}`);e.bones.push(l)}const n=d.target;if(e.target=s.findBone(n),e.target==null)throw new Error(`Transform constraint target bone not found: ${n}`);e.local=this.getValue(d,"local",!1),e.relative=this.getValue(d,"relative",!1),e.offsetRotation=this.getValue(d,"rotation",0),e.offsetX=this.getValue(d,"x",0)*r,e.offsetY=this.getValue(d,"y",0)*r,e.offsetScaleX=this.getValue(d,"scaleX",0),e.offsetScaleY=this.getValue(d,"scaleY",0),e.offsetShearY=this.getValue(d,"shearY",0),e.rotateMix=this.getValue(d,"rotateMix",1),e.translateMix=this.getValue(d,"translateMix",1),e.scaleMix=this.getValue(d,"scaleMix",1),e.shearMix=this.getValue(d,"shearMix",1),s.transformConstraints.push(e)}if(i.path)for(let m=0;m<i.path.length;m++){const d=i.path[m],e=new Vs(d.name);e.order=this.getValue(d,"order",0),e.skinRequired=this.getValue(d,"skin",!1);for(let a=0;a<d.bones.length;a++){const h=d.bones[a],l=s.findBone(h);if(l==null)throw new Error(`Transform constraint bone not found: ${h}`);e.bones.push(l)}const n=d.target;if(e.target=s.findSlot(n),e.target==null)throw new Error(`Path target slot not found: ${n}`);e.positionMode=ge.positionModeFromString(this.getValue(d,"positionMode","percent")),e.spacingMode=ge.spacingModeFromString(this.getValue(d,"spacingMode","length")),e.rotateMode=ge.rotateModeFromString(this.getValue(d,"rotateMode","tangent")),e.offsetRotation=this.getValue(d,"rotation",0),e.position=this.getValue(d,"position",0),e.positionMode==at.Fixed&&(e.position*=r),e.spacing=this.getValue(d,"spacing",0),(e.spacingMode==pt.Length||e.spacingMode==pt.Fixed)&&(e.spacing*=r),e.rotateMix=this.getValue(d,"rotateMix",1),e.translateMix=this.getValue(d,"translateMix",1),s.pathConstraints.push(e)}if(i.skins)for(let m=0;m<i.skins.length;m++){const d=i.skins[m],e=new Ne(d.name);if(d.bones)for(let n=0;n<d.bones.length;n++){const a=s.findBone(d.bones[n]);if(a==null)throw new Error(`Skin bone not found: ${d.bones[m]}`);e.bones.push(a)}if(d.ik)for(let n=0;n<d.ik.length;n++){const a=s.findIkConstraint(d.ik[n]);if(a==null)throw new Error(`Skin IK constraint not found: ${d.ik[m]}`);e.constraints.push(a)}if(d.transform)for(let n=0;n<d.transform.length;n++){const a=s.findTransformConstraint(d.transform[n]);if(a==null)throw new Error(`Skin transform constraint not found: ${d.transform[m]}`);e.constraints.push(a)}if(d.path)for(let n=0;n<d.path.length;n++){const a=s.findPathConstraint(d.path[n]);if(a==null)throw new Error(`Skin path constraint not found: ${d.path[m]}`);e.constraints.push(a)}for(const n in d.attachments){const a=s.findSlot(n);if(a==null)throw new Error(`Slot not found: ${n}`);const h=d.attachments[n];for(const l in h){const u=this.readAttachment(h[l],e,a.index,l,s);u!=null&&e.setAttachment(a.index,l,u)}}s.skins.push(e),e.name=="default"&&(s.defaultSkin=e)}for(let m=0,d=this.linkedMeshes.length;m<d;m++){const e=this.linkedMeshes[m],n=e.skin==null?s.defaultSkin:s.findSkin(e.skin);if(n==null)throw new Error(`Skin not found: ${e.skin}`);const a=n.getAttachment(e.slotIndex,e.parent);if(a==null)throw new Error(`Parent mesh not found: ${e.parent}`);e.mesh.deformAttachment=e.inheritDeform?a:e.mesh,e.mesh.setParentMesh(a)}if(this.linkedMeshes.length=0,i.events)for(const m in i.events){const d=i.events[m],e=new Ts(m);e.intValue=this.getValue(d,"int",0),e.floatValue=this.getValue(d,"float",0),e.stringValue=this.getValue(d,"string",""),e.audioPath=this.getValue(d,"audio",null),e.audioPath!=null&&(e.volume=this.getValue(d,"volume",1),e.balance=this.getValue(d,"balance",0)),s.events.push(e)}if(i.animations)for(const m in i.animations){const d=i.animations[m];this.readAnimation(d,m,s)}return s}readAttachment(t,r,s,i,o){const m=this.scale;switch(i=this.getValue(t,"name",i),this.getValue(t,"type","region")){case"region":{const e=this.getValue(t,"path",i),n=this.attachmentLoader.newRegionAttachment(r,i,e);if(n==null)return null;n.path=e,n.x=this.getValue(t,"x",0)*m,n.y=this.getValue(t,"y",0)*m,n.scaleX=this.getValue(t,"scaleX",1),n.scaleY=this.getValue(t,"scaleY",1),n.rotation=this.getValue(t,"rotation",0),n.width=t.width*m,n.height=t.height*m;const a=this.getValue(t,"color",null);return a!=null&&n.color.setFromString(a),n}case"boundingbox":{const e=this.attachmentLoader.newBoundingBoxAttachment(r,i);if(e==null)return null;this.readVertices(t,e,t.vertexCount<<1);const n=this.getValue(t,"color",null);return n!=null&&e.color.setFromString(n),e}case"mesh":case"linkedmesh":{const e=this.getValue(t,"path",i),n=this.attachmentLoader.newMeshAttachment(r,i,e);if(n==null)return null;n.path=e;const a=this.getValue(t,"color",null);a!=null&&n.color.setFromString(a),n.width=this.getValue(t,"width",0)*m,n.height=this.getValue(t,"height",0)*m;const h=this.getValue(t,"parent",null);if(h!=null)return this.linkedMeshes.push(new jn(n,this.getValue(t,"skin",null),s,h,this.getValue(t,"deform",!0))),n;const l=t.uvs;return this.readVertices(t,n,l.length),n.triangles=t.triangles,n.regionUVs=new Float32Array(l),n.edges=this.getValue(t,"edges",null),n.hullLength=this.getValue(t,"hull",0)*2,n}case"path":{const e=this.attachmentLoader.newPathAttachment(r,i);if(e==null)return null;e.closed=this.getValue(t,"closed",!1),e.constantSpeed=this.getValue(t,"constantSpeed",!0);const n=t.vertexCount;this.readVertices(t,e,n<<1);const a=C.newArray(n/3,0);for(let l=0;l<t.lengths.length;l++)a[l]=t.lengths[l]*m;e.lengths=a;const h=this.getValue(t,"color",null);return h!=null&&e.color.setFromString(h),e}case"point":{const e=this.attachmentLoader.newPointAttachment(r,i);if(e==null)return null;e.x=this.getValue(t,"x",0)*m,e.y=this.getValue(t,"y",0)*m,e.rotation=this.getValue(t,"rotation",0);const n=this.getValue(t,"color",null);return n!=null&&e.color.setFromString(n),e}case"clipping":{const e=this.attachmentLoader.newClippingAttachment(r,i);if(e==null)return null;const n=this.getValue(t,"end",null);if(n!=null){const l=o.findSlot(n);if(l==null)throw new Error(`Clipping end slot not found: ${n}`);e.endSlot=l}const a=t.vertexCount;this.readVertices(t,e,a<<1);const h=this.getValue(t,"color",null);return h!=null&&e.color.setFromString(h),e}}return null}readVertices(t,r,s){const i=this.scale;r.worldVerticesLength=s;const o=t.vertices;if(s==o.length){const e=C.toFloatArray(o);if(i!=1)for(let n=0,a=o.length;n<a;n++)e[n]*=i;r.vertices=e;return}const m=new Array,d=new Array;for(let e=0,n=o.length;e<n;){const a=o[e++];d.push(a);for(let h=e+a*4;e<h;e+=4)d.push(o[e]),m.push(o[e+1]*i),m.push(o[e+2]*i),m.push(o[e+3])}r.bones=d,r.vertices=C.toFloatArray(m)}readAnimation(t,r,s){const i=this.scale,o=new Array;let m=0;if(t.slots)for(const e in t.slots){const n=t.slots[e],a=s.findSlotIndex(e);if(a==-1)throw new Error(`Slot not found: ${e}`);for(const h in n){const l=n[h];if(h=="attachment"){const u=new ps(l.length);u.slotIndex=a;let f=0;for(let g=0;g<l.length;g++){const w=l[g];u.setFrame(f++,this.getValue(w,"time",0),w.name)}o.push(u),m=Math.max(m,u.frames[u.getFrameCount()-1])}else if(h=="color"){const u=new St(l.length);u.slotIndex=a;let f=0;for(let g=0;g<l.length;g++){const w=l[g],E=new T;E.setFromString(w.color||"ffffffff"),u.setFrame(f,this.getValue(w,"time",0),E.r,E.g,E.b,E.a),this.readCurve(w,u,f),f++}o.push(u),m=Math.max(m,u.frames[(u.getFrameCount()-1)*St.ENTRIES])}else if(h=="twoColor"){const u=new nt(l.length);u.slotIndex=a;let f=0;for(let g=0;g<l.length;g++){const w=l[g],E=new T,x=new T;E.setFromString(w.light),x.setFromString(w.dark),u.setFrame(f,this.getValue(w,"time",0),E.r,E.g,E.b,E.a,x.r,x.g,x.b),this.readCurve(w,u,f),f++}o.push(u),m=Math.max(m,u.frames[(u.getFrameCount()-1)*nt.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${h} (${e})`)}}if(t.bones)for(const e in t.bones){const n=t.bones[e],a=s.findBoneIndex(e);if(a==-1)throw new Error(`Bone not found: ${e}`);for(const h in n){const l=n[h];if(h==="rotate"){const u=new oe(l.length);u.boneIndex=a;let f=0;for(let g=0;g<l.length;g++){const w=l[g];u.setFrame(f,this.getValue(w,"time",0),this.getValue(w,"angle",0)),this.readCurve(w,u,f),f++}o.push(u),m=Math.max(m,u.frames[(u.getFrameCount()-1)*oe.ENTRIES])}else if(h==="translate"||h==="scale"||h==="shear"){let u=null,f=1,g=0;h==="scale"?(u=new Es(l.length),g=1):h==="shear"?u=new bs(l.length):(u=new Tt(l.length),f=i),u.boneIndex=a;let w=0;for(let E=0;E<l.length;E++){const x=l[E],p=this.getValue(x,"x",g),b=this.getValue(x,"y",g);u.setFrame(w,this.getValue(x,"time",0),p*f,b*f),this.readCurve(x,u,w),w++}o.push(u),m=Math.max(m,u.frames[(u.getFrameCount()-1)*Tt.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${h} (${e})`)}}if(t.ik)for(const e in t.ik){const n=t.ik[e],a=s.findIkConstraint(e),h=new mt(n.length);h.ikConstraintIndex=s.ikConstraints.indexOf(a);let l=0;for(let u=0;u<n.length;u++){const f=n[u];h.setFrame(l,this.getValue(f,"time",0),this.getValue(f,"mix",1),this.getValue(f,"softness",0)*i,this.getValue(f,"bendPositive",!0)?1:-1,this.getValue(f,"compress",!1),this.getValue(f,"stretch",!1)),this.readCurve(f,h,l),l++}o.push(h),m=Math.max(m,h.frames[(h.getFrameCount()-1)*mt.ENTRIES])}if(t.transform)for(const e in t.transform){const n=t.transform[e],a=s.findTransformConstraint(e),h=new Rt(n.length);h.transformConstraintIndex=s.transformConstraints.indexOf(a);let l=0;for(let u=0;u<n.length;u++){const f=n[u];h.setFrame(l,this.getValue(f,"time",0),this.getValue(f,"rotateMix",1),this.getValue(f,"translateMix",1),this.getValue(f,"scaleMix",1),this.getValue(f,"shearMix",1)),this.readCurve(f,h,l),l++}o.push(h),m=Math.max(m,h.frames[(h.getFrameCount()-1)*Rt.ENTRIES])}if(t.path)for(const e in t.path){const n=t.path[e],a=s.findPathConstraintIndex(e);if(a==-1)throw new Error(`Path constraint not found: ${e}`);const h=s.pathConstraints[a];for(const l in n){const u=n[l];if(l==="position"||l==="spacing"){let f=null,g=1;l==="spacing"?(f=new Is(u.length),(h.spacingMode==pt.Length||h.spacingMode==pt.Fixed)&&(g=i)):(f=new jt(u.length),h.positionMode==at.Fixed&&(g=i)),f.pathConstraintIndex=a;let w=0;for(let E=0;E<u.length;E++){const x=u[E];f.setFrame(w,this.getValue(x,"time",0),this.getValue(x,l,0)*g),this.readCurve(x,f,w),w++}o.push(f),m=Math.max(m,f.frames[(f.getFrameCount()-1)*jt.ENTRIES])}else if(l==="mix"){const f=new Ut(u.length);f.pathConstraintIndex=a;let g=0;for(let w=0;w<u.length;w++){const E=u[w];f.setFrame(g,this.getValue(E,"time",0),this.getValue(E,"rotateMix",1),this.getValue(E,"translateMix",1)),this.readCurve(E,f,g),g++}o.push(f),m=Math.max(m,f.frames[(f.getFrameCount()-1)*Ut.ENTRIES])}}}if(t.deform)for(const e in t.deform){const n=t.deform[e],a=s.findSkin(e);if(a!=null)for(const h in n){const l=n[h],u=s.findSlotIndex(h);if(u==-1)throw new Error(`Slot not found: ${l.name}`);for(const f in l){const g=l[f],w=a.getAttachment(u,f);if(w==null)throw new Error(`Deform attachment not found: ${g.name}`);const E=w.bones!=null,x=w.vertices,p=E?x.length/3*2:x.length,b=new ys(g.length);b.slotIndex=u,b.attachment=w;let y=0;for(let S=0;S<g.length;S++){const I=g[S];let v;const M=this.getValue(I,"vertices",null);if(M==null)v=E?C.newFloatArray(p):x;else{v=C.newFloatArray(p);const P=this.getValue(I,"offset",0);if(C.arrayCopy(M,0,v,P,M.length),i!=1)for(let V=P,k=V+M.length;V<k;V++)v[V]*=i;if(!E)for(let V=0;V<p;V++)v[V]+=x[V]}b.setFrame(y,this.getValue(I,"time",0),v),this.readCurve(I,b,y),y++}o.push(b),m=Math.max(m,b.frames[b.getFrameCount()-1])}}}let d=t.drawOrder;if(d==null&&(d=t.draworder),d!=null){const e=new Rs(d.length),n=s.slots.length;let a=0;for(let h=0;h<d.length;h++){const l=d[h];let u=null;const f=this.getValue(l,"offsets",null);if(f!=null){u=C.newArray(n,-1);const g=C.newArray(n-f.length,0);let w=0,E=0;for(let x=0;x<f.length;x++){const p=f[x],b=s.findSlotIndex(p.slot);if(b==-1)throw new Error(`Slot not found: ${p.slot}`);for(;w!=b;)g[E++]=w++;u[w+p.offset]=w++}for(;w<n;)g[E++]=w++;for(let x=n-1;x>=0;x--)u[x]==-1&&(u[x]=g[--E])}e.setFrame(a++,this.getValue(l,"time",0),u)}o.push(e),m=Math.max(m,e.frames[e.getFrameCount()-1])}if(t.events){const e=new Ss(t.events.length);let n=0;for(let a=0;a<t.events.length;a++){const h=t.events[a],l=s.findEvent(h.name);if(l==null)throw new Error(`Event not found: ${h.name}`);const u=new vs(C.toSinglePrecision(this.getValue(h,"time",0)),l);u.intValue=this.getValue(h,"int",l.intValue),u.floatValue=this.getValue(h,"float",l.floatValue),u.stringValue=this.getValue(h,"string",l.stringValue),u.data.audioPath!=null&&(u.volume=this.getValue(h,"volume",1),u.balance=this.getValue(h,"balance",0)),e.setFrame(n++,u)}o.push(e),m=Math.max(m,e.frames[e.getFrameCount()-1])}if(isNaN(m))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new ht(r,o,m))}readCurve(t,r,s){if(t.hasOwnProperty("curve"))if(t.curve==="stepped")r.setStepped(s);else{const i=t.curve;r.setCurve(s,i,this.getValue(t,"c2",0),this.getValue(t,"c3",1),this.getValue(t,"c4",1))}}getValue(t,r,s){return t[r]!==void 0?t[r]:s}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return et.NORMAL;if(t=="additive")return et.ADD;if(t=="multiply")return et.MULTIPLY;if(t=="screen")return et.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return at.Fixed;if(t=="percent")return at.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return pt.Length;if(t=="fixed")return pt.Fixed;if(t=="percent")return pt.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return vt.Tangent;if(t=="chain")return vt.Chain;if(t=="chainscale")return vt.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return st.Normal;if(t=="onlytranslation")return st.OnlyTranslation;if(t=="norotationorreflection")return st.NoRotationOrReflection;if(t=="noscale")return st.NoScale;if(t=="noscaleorreflection")return st.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}},jn=class{constructor(t,r,s,i,o){this.mesh=t,this.skin=r,this.slotIndex=s,this.parent=i,this.inheritDeform=o}},Ns=class{constructor(t){if(t==null)throw new Error("name cannot be null.");this.name=t}};const Ys=class extends Ns{constructor(t){super(t),this.id=(Ys.nextID++&65535)<<11,this.worldVerticesLength=0}computeWorldVerticesOld(t,r){this.computeWorldVertices(t,0,this.worldVerticesLength,r,0,2)}computeWorldVertices(t,r,s,i,o,m){s=o+(s>>1)*m;const d=t.bone.skeleton,e=t.attachmentVertices;let n=this.vertices;const a=this.bones;if(a==null){e.length>0&&(n=e);const f=t.bone.matrix,g=f.tx,w=f.ty,E=f.a,x=f.c,p=f.b,b=f.d;for(let y=r,S=o;S<s;y+=2,S+=m){const I=n[y],v=n[y+1];i[S]=I*E+v*x+g,i[S+1]=I*p+v*b+w}return}let h=0,l=0;for(let f=0;f<r;f+=2){const g=a[h];h+=g+1,l+=g}const u=d.bones;if(e.length==0)for(let f=o,g=l*3;f<s;f+=m){let w=0,E=0,x=a[h++];for(x+=h;h<x;h++,g+=3){const p=u[a[h]].matrix,b=n[g],y=n[g+1],S=n[g+2];w+=(b*p.a+y*p.c+p.tx)*S,E+=(b*p.b+y*p.d+p.ty)*S}i[f]=w,i[f+1]=E}else{const f=e;for(let g=o,w=l*3,E=l<<1;g<s;g+=m){let x=0,p=0,b=a[h++];for(b+=h;h<b;h++,w+=3,E+=2){const y=u[a[h]].matrix,S=n[w]+f[E],I=n[w+1]+f[E+1],v=n[w+2];x+=(S*y.a+I*y.c+y.tx)*v,p+=(S*y.b+I*y.d+y.ty)*v}i[g]=x,i[g+1]=p}}}applyDeform(t){return this==t}};let fe=Ys;fe.nextID=0;let Jn=class extends fe{constructor(t){super(t),this.type=B.BoundingBox,this.color=new T(1,1,1,1)}},Kn=class extends fe{constructor(t){super(t),this.type=B.Clipping,this.color=new T(.2275,.2275,.8078,1)}},Qn=class extends fe{constructor(t){super(t),this.type=B.Mesh,this.color=new T(1,1,1,1),this.inheritDeform=!1,this.tempColor=new T(0,0,0,0)}applyDeform(t){return this==t||this.inheritDeform&&this.parentMesh==t}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}},tr=class extends fe{constructor(t){super(t),this.type=B.Path,this.closed=!1,this.constantSpeed=!1,this.color=new T(1,1,1,1)}},er=class extends fe{constructor(t){super(t),this.type=B.Point,this.color=new T(.38,.94,0,1)}computeWorldPosition(t,r){const s=t.matrix;return r.x=this.x*s.a+this.y*s.c+t.worldX,r.y=this.x*s.b+this.y*s.d+t.worldY,r}computeWorldRotation(t){const r=t.matrix,s=F.cosDeg(this.rotation),i=F.sinDeg(this.rotation),o=s*r.a+i*r.c,m=s*r.b+i*r.d;return Math.atan2(m,o)*F.radDeg}};class sr{constructor(t,r){if(this.attachmentVertices=new Array,t==null)throw new Error("data cannot be null.");if(r==null)throw new Error("bone cannot be null.");this.data=t,this.bone=r,this.color=new T,this.darkColor=t.darkColor==null?null:new T,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.attachmentVertices.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}}const dt=class extends Ns{constructor(t){super(t),this.type=B.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new T(1,1,1,1),this.offset=C.newFloatArray(8),this.uvs=C.newFloatArray(8),this.tempColor=new T(1,1,1,1)}updateOffset(){const t=this.width/this.region.originalWidth*this.scaleX,r=this.height/this.region.originalHeight*this.scaleY,s=-this.width/2*this.scaleX+this.region.offsetX*t,i=-this.height/2*this.scaleY+this.region.offsetY*r,o=s+this.region.width*t,m=i+this.region.height*r,d=this.rotation*Math.PI/180,e=Math.cos(d),n=Math.sin(d),a=s*e+this.x,h=s*n,l=i*e+this.y,u=i*n,f=o*e+this.x,g=o*n,w=m*e+this.y,E=m*n,x=this.offset;x[dt.OX1]=a-u,x[dt.OY1]=l+h,x[dt.OX2]=a-E,x[dt.OY2]=w+h,x[dt.OX3]=f-E,x[dt.OY3]=w+g,x[dt.OX4]=f-u,x[dt.OY4]=l+g}setRegion(t){this.region=t;const r=this.uvs;t.rotate?(r[2]=t.u,r[3]=t.v2,r[4]=t.u,r[5]=t.v,r[6]=t.u2,r[7]=t.v,r[0]=t.u2,r[1]=t.v2):(r[0]=t.u,r[1]=t.v2,r[2]=t.u,r[3]=t.v,r[4]=t.u2,r[5]=t.v,r[6]=t.u2,r[7]=t.v2)}computeWorldVertices(t,r,s,i){const o=this.offset,m=t instanceof sr?t.bone.matrix:t.matrix,d=m.tx,e=m.ty,n=m.a,a=m.c,h=m.b,l=m.d;let u=0,f=0;u=o[dt.OX1],f=o[dt.OY1],r[s]=u*n+f*a+d,r[s+1]=u*h+f*l+e,s+=i,u=o[dt.OX2],f=o[dt.OY2],r[s]=u*n+f*a+d,r[s+1]=u*h+f*l+e,s+=i,u=o[dt.OX3],f=o[dt.OY3],r[s]=u*n+f*a+d,r[s+1]=u*h+f*l+e,s+=i,u=o[dt.OX4],f=o[dt.OY4],r[s]=u*n+f*a+d,r[s+1]=u*h+f*l+e}};let X=dt;X.OX1=0;X.OY1=1;X.OX2=2;X.OY2=3;X.OX3=4;X.OY3=5;X.OX4=6;X.OY4=7;X.X1=0;X.Y1=1;X.C1R=2;X.C1G=3;X.C1B=4;X.C1A=5;X.U1=6;X.V1=7;X.X2=8;X.Y2=9;X.C2R=10;X.C2G=11;X.C2B=12;X.C2A=13;X.U2=14;X.V2=15;X.X3=16;X.Y3=17;X.C3R=18;X.C3G=19;X.C3B=20;X.C3A=21;X.U3=22;X.V3=23;X.X4=24;X.Y4=25;X.C4R=26;X.C4G=27;X.C4B=28;X.C4A=29;X.U4=30;X.V4=31;new is(2);let ut=class{constructor(t,r,s){if(t==null)throw new Error("name cannot be null.");if(r==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=r,this.duration=s}apply(t,r,s,i,o,m,d,e){if(t==null)throw new Error("skeleton cannot be null.");i&&this.duration!=0&&(s%=this.duration,r>0&&(r%=this.duration));const n=this.timelines;for(let a=0,h=n.length;a<h;a++)n[a].apply(t,r,s,o,m,d,e)}static binarySearch(t,r,s=1){let i=0,o=t.length/s-2;if(o==0)return s;let m=o>>>1;for(;;){if(t[(m+1)*s]<=r?i=m+1:o=m,i==o)return(i+1)*s;m=i+o>>>1}}static linearSearch(t,r,s){for(let i=0,o=t.length-s;i<=o;i+=s)if(t[i]>r)return i;return-1}};const tt=class{constructor(c){if(c<=0)throw new Error(`frameCount must be > 0: ${c}`);this.curves=C.newFloatArray((c-1)*tt.BEZIER_SIZE)}getFrameCount(){return this.curves.length/tt.BEZIER_SIZE+1}setLinear(c){this.curves[c*tt.BEZIER_SIZE]=tt.LINEAR}setStepped(c){this.curves[c*tt.BEZIER_SIZE]=tt.STEPPED}getCurveType(c){const t=c*tt.BEZIER_SIZE;if(t==this.curves.length)return tt.LINEAR;const r=this.curves[t];return r==tt.LINEAR?tt.LINEAR:r==tt.STEPPED?tt.STEPPED:tt.BEZIER}setCurve(c,t,r,s,i){const o=(-t*2+s)*.03,m=(-r*2+i)*.03,d=((t-s)*3+1)*.006,e=((r-i)*3+1)*.006;let n=o*2+d,a=m*2+e,h=t*.3+o+d*.16666667,l=r*.3+m+e*.16666667,u=c*tt.BEZIER_SIZE;const f=this.curves;f[u++]=tt.BEZIER;let g=h,w=l;for(let E=u+tt.BEZIER_SIZE-1;u<E;u+=2)f[u]=g,f[u+1]=w,h+=n,l+=a,n+=d,a+=e,g+=h,w+=l}getCurvePercent(c,t){t=F.clamp(t,0,1);const r=this.curves;let s=c*tt.BEZIER_SIZE;const i=r[s];if(i==tt.LINEAR)return t;if(i==tt.STEPPED)return 0;s++;let o=0;for(let d=s,e=s+tt.BEZIER_SIZE-1;s<e;s+=2)if(o=r[s],o>=t){let n,a;return s==d?(n=0,a=0):(n=r[s-2],a=r[s-1]),a+(r[s+1]-a)*(t-n)/(o-n)}const m=r[s-1];return m+(1-m)*(t-o)/(1-o)}};let Ct=tt;Ct.LINEAR=0;Ct.STEPPED=1;Ct.BEZIER=2;Ct.BEZIER_SIZE=10*2-1;const te=class extends Ct{constructor(c){super(c),this.frames=C.newFloatArray(c<<1)}getPropertyId(){return 0+this.boneIndex}setFrame(c,t,r){c<<=1,this.frames[c]=t,this.frames[c+te.ROTATION]=r}apply(c,t,r,s,i,o,m){const d=this.frames,e=c.bones[this.boneIndex];if(r<d[0]){switch(o){case R.setup:e.rotation=e.data.rotation;return;case R.first:const f=e.data.rotation-e.rotation;e.rotation+=(f-(16384-(16384.499999999996-f/360|0))*360)*i}return}if(r>=d[d.length-te.ENTRIES]){let f=d[d.length+te.PREV_ROTATION];switch(o){case R.setup:e.rotation=e.data.rotation+f*i;break;case R.first:case R.replace:f+=e.data.rotation-e.rotation,f-=(16384-(16384.499999999996-f/360|0))*360;case R.add:e.rotation+=f*i}return}const n=ut.binarySearch(d,r,te.ENTRIES),a=d[n+te.PREV_ROTATION],h=d[n],l=this.getCurvePercent((n>>1)-1,1-(r-h)/(d[n+te.PREV_TIME]-h));let u=d[n+te.ROTATION]-a;switch(u=a+(u-(16384-(16384.499999999996-u/360|0))*360)*l,o){case R.setup:e.rotation=e.data.rotation+(u-(16384-(16384.499999999996-u/360|0))*360)*i;break;case R.first:case R.replace:u+=e.data.rotation-e.rotation;case R.add:e.rotation+=(u-(16384-(16384.499999999996-u/360|0))*360)*i}}};let Ee=te;Ee.ENTRIES=2;Ee.PREV_TIME=-2;Ee.PREV_ROTATION=-1;Ee.ROTATION=1;const Et=class extends Ct{constructor(c){super(c),this.frames=C.newFloatArray(c*Et.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(c,t,r,s){c*=Et.ENTRIES,this.frames[c]=t,this.frames[c+Et.X]=r,this.frames[c+Et.Y]=s}apply(c,t,r,s,i,o,m){const d=this.frames,e=c.bones[this.boneIndex];if(r<d[0]){switch(o){case R.setup:e.x=e.data.x,e.y=e.data.y;return;case R.first:e.x+=(e.data.x-e.x)*i,e.y+=(e.data.y-e.y)*i}return}let n=0,a=0;if(r>=d[d.length-Et.ENTRIES])n=d[d.length+Et.PREV_X],a=d[d.length+Et.PREV_Y];else{const h=ut.binarySearch(d,r,Et.ENTRIES);n=d[h+Et.PREV_X],a=d[h+Et.PREV_Y];const l=d[h],u=this.getCurvePercent(h/Et.ENTRIES-1,1-(r-l)/(d[h+Et.PREV_TIME]-l));n+=(d[h+Et.X]-n)*u,a+=(d[h+Et.Y]-a)*u}switch(o){case R.setup:e.x=e.data.x+n*i,e.y=e.data.y+a*i;break;case R.first:case R.replace:e.x+=(e.data.x+n-e.x)*i,e.y+=(e.data.y+a-e.y)*i;break;case R.add:e.x+=n*i,e.y+=a*i}}};let zt=Et;zt.ENTRIES=3;zt.PREV_TIME=-3;zt.PREV_X=-2;zt.PREV_Y=-1;zt.X=1;zt.Y=2;let nr=class Xt extends zt{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,r,s,i,o,m,d){const e=this.frames,n=t.bones[this.boneIndex];if(s<e[0]){switch(m){case R.setup:n.scaleX=n.data.scaleX,n.scaleY=n.data.scaleY;return;case R.first:n.scaleX+=(n.data.scaleX-n.scaleX)*o,n.scaleY+=(n.data.scaleY-n.scaleY)*o}return}let a=0,h=0;if(s>=e[e.length-Xt.ENTRIES])a=e[e.length+Xt.PREV_X]*n.data.scaleX,h=e[e.length+Xt.PREV_Y]*n.data.scaleY;else{const l=ut.binarySearch(e,s,Xt.ENTRIES);a=e[l+Xt.PREV_X],h=e[l+Xt.PREV_Y];const u=e[l],f=this.getCurvePercent(l/Xt.ENTRIES-1,1-(s-u)/(e[l+Xt.PREV_TIME]-u));a=(a+(e[l+Xt.X]-a)*f)*n.data.scaleX,h=(h+(e[l+Xt.Y]-h)*f)*n.data.scaleY}if(o==1)m==R.add?(n.scaleX+=a-n.data.scaleX,n.scaleY+=h-n.data.scaleY):(n.scaleX=a,n.scaleY=h);else{let l=0,u=0;if(d==K.mixOut)switch(m){case R.setup:l=n.data.scaleX,u=n.data.scaleY,n.scaleX=l+(Math.abs(a)*F.signum(l)-l)*o,n.scaleY=u+(Math.abs(h)*F.signum(u)-u)*o;break;case R.first:case R.replace:l=n.scaleX,u=n.scaleY,n.scaleX=l+(Math.abs(a)*F.signum(l)-l)*o,n.scaleY=u+(Math.abs(h)*F.signum(u)-u)*o;break;case R.add:l=n.scaleX,u=n.scaleY,n.scaleX=l+(Math.abs(a)*F.signum(l)-n.data.scaleX)*o,n.scaleY=u+(Math.abs(h)*F.signum(u)-n.data.scaleY)*o}else switch(m){case R.setup:l=Math.abs(n.data.scaleX)*F.signum(a),u=Math.abs(n.data.scaleY)*F.signum(h),n.scaleX=l+(a-l)*o,n.scaleY=u+(h-u)*o;break;case R.first:case R.replace:l=Math.abs(n.scaleX)*F.signum(a),u=Math.abs(n.scaleY)*F.signum(h),n.scaleX=l+(a-l)*o,n.scaleY=u+(h-u)*o;break;case R.add:l=F.signum(a),u=F.signum(h),n.scaleX=Math.abs(n.scaleX)*l+(a-Math.abs(n.data.scaleX)*l)*o,n.scaleY=Math.abs(n.scaleY)*u+(h-Math.abs(n.data.scaleY)*u)*o}}}},rr=class Bt extends zt{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,r,s,i,o,m,d){const e=this.frames,n=t.bones[this.boneIndex];if(s<e[0]){switch(m){case R.setup:n.shearX=n.data.shearX,n.shearY=n.data.shearY;return;case R.first:n.shearX+=(n.data.shearX-n.shearX)*o,n.shearY+=(n.data.shearY-n.shearY)*o}return}let a=0,h=0;if(s>=e[e.length-Bt.ENTRIES])a=e[e.length+Bt.PREV_X],h=e[e.length+Bt.PREV_Y];else{const l=ut.binarySearch(e,s,Bt.ENTRIES);a=e[l+Bt.PREV_X],h=e[l+Bt.PREV_Y];const u=e[l],f=this.getCurvePercent(l/Bt.ENTRIES-1,1-(s-u)/(e[l+Bt.PREV_TIME]-u));a=a+(e[l+Bt.X]-a)*f,h=h+(e[l+Bt.Y]-h)*f}switch(m){case R.setup:n.shearX=n.data.shearX+a*o,n.shearY=n.data.shearY+h*o;break;case R.first:case R.replace:n.shearX+=(n.data.shearX+a-n.shearX)*o,n.shearY+=(n.data.shearY+h-n.shearY)*o;break;case R.add:n.shearX+=a*o,n.shearY+=h*o}}};const Z=class extends Ct{constructor(c){super(c),this.frames=C.newFloatArray(c*Z.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(c,t,r,s,i,o){c*=Z.ENTRIES,this.frames[c]=t,this.frames[c+Z.R]=r,this.frames[c+Z.G]=s,this.frames[c+Z.B]=i,this.frames[c+Z.A]=o}apply(c,t,r,s,i,o,m){const d=c.slots[this.slotIndex],e=this.frames;if(r<e[0]){switch(o){case R.setup:d.color.setFromColor(d.data.color);return;case R.first:const u=d.color,f=d.data.color;u.add((f.r-u.r)*i,(f.g-u.g)*i,(f.b-u.b)*i,(f.a-u.a)*i)}return}let n=0,a=0,h=0,l=0;if(r>=e[e.length-Z.ENTRIES]){const u=e.length;n=e[u+Z.PREV_R],a=e[u+Z.PREV_G],h=e[u+Z.PREV_B],l=e[u+Z.PREV_A]}else{const u=ut.binarySearch(e,r,Z.ENTRIES);n=e[u+Z.PREV_R],a=e[u+Z.PREV_G],h=e[u+Z.PREV_B],l=e[u+Z.PREV_A];const f=e[u],g=this.getCurvePercent(u/Z.ENTRIES-1,1-(r-f)/(e[u+Z.PREV_TIME]-f));n+=(e[u+Z.R]-n)*g,a+=(e[u+Z.G]-a)*g,h+=(e[u+Z.B]-h)*g,l+=(e[u+Z.A]-l)*g}if(i==1)d.color.set(n,a,h,l);else{const u=d.color;o==R.setup&&u.setFromColor(d.data.color),u.add((n-u.r)*i,(a-u.g)*i,(h-u.b)*i,(l-u.a)*i)}}};let Mt=Z;Mt.ENTRIES=5;Mt.PREV_TIME=-5;Mt.PREV_R=-4;Mt.PREV_G=-3;Mt.PREV_B=-2;Mt.PREV_A=-1;Mt.R=1;Mt.G=2;Mt.B=3;Mt.A=4;const _=class extends Ct{constructor(c){super(c),this.frames=C.newFloatArray(c*_.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(c,t,r,s,i,o,m,d,e){c*=_.ENTRIES,this.frames[c]=t,this.frames[c+_.R]=r,this.frames[c+_.G]=s,this.frames[c+_.B]=i,this.frames[c+_.A]=o,this.frames[c+_.R2]=m,this.frames[c+_.G2]=d,this.frames[c+_.B2]=e}apply(c,t,r,s,i,o,m){const d=c.slots[this.slotIndex],e=this.frames;if(r<e[0]){switch(o){case R.setup:d.color.setFromColor(d.data.color),d.darkColor.setFromColor(d.data.darkColor);return;case R.first:const w=d.color,E=d.darkColor,x=d.data.color,p=d.data.darkColor;w.add((x.r-w.r)*i,(x.g-w.g)*i,(x.b-w.b)*i,(x.a-w.a)*i),E.add((p.r-E.r)*i,(p.g-E.g)*i,(p.b-E.b)*i,0)}return}let n=0,a=0,h=0,l=0,u=0,f=0,g=0;if(r>=e[e.length-_.ENTRIES]){const w=e.length;n=e[w+_.PREV_R],a=e[w+_.PREV_G],h=e[w+_.PREV_B],l=e[w+_.PREV_A],u=e[w+_.PREV_R2],f=e[w+_.PREV_G2],g=e[w+_.PREV_B2]}else{const w=ut.binarySearch(e,r,_.ENTRIES);n=e[w+_.PREV_R],a=e[w+_.PREV_G],h=e[w+_.PREV_B],l=e[w+_.PREV_A],u=e[w+_.PREV_R2],f=e[w+_.PREV_G2],g=e[w+_.PREV_B2];const E=e[w],x=this.getCurvePercent(w/_.ENTRIES-1,1-(r-E)/(e[w+_.PREV_TIME]-E));n+=(e[w+_.R]-n)*x,a+=(e[w+_.G]-a)*x,h+=(e[w+_.B]-h)*x,l+=(e[w+_.A]-l)*x,u+=(e[w+_.R2]-u)*x,f+=(e[w+_.G2]-f)*x,g+=(e[w+_.B2]-g)*x}if(i==1)d.color.set(n,a,h,l),d.darkColor.set(u,f,g,1);else{const w=d.color,E=d.darkColor;o==R.setup&&(w.setFromColor(d.data.color),E.setFromColor(d.data.darkColor)),w.add((n-w.r)*i,(a-w.g)*i,(h-w.b)*i,(l-w.a)*i),E.add((u-E.r)*i,(f-E.g)*i,(g-E.b)*i,0)}}};let ct=_;ct.ENTRIES=8;ct.PREV_TIME=-8;ct.PREV_R=-7;ct.PREV_G=-6;ct.PREV_B=-5;ct.PREV_A=-4;ct.PREV_R2=-3;ct.PREV_G2=-2;ct.PREV_B2=-1;ct.R=1;ct.G=2;ct.B=3;ct.A=4;ct.R2=5;ct.G2=6;ct.B2=7;let or=class{constructor(t){this.frames=C.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,r,s){this.frames[t]=r,this.attachmentNames[t]=s}apply(t,r,s,i,o,m,d){const e=t.slots[this.slotIndex];if(d==K.mixOut&&m==R.setup){const l=e.data.attachmentName;e.setAttachment(l==null?null:t.getAttachment(this.slotIndex,l));return}const n=this.frames;if(s<n[0]){if(m==R.setup||m==R.first){const l=e.data.attachmentName;e.setAttachment(l==null?null:t.getAttachment(this.slotIndex,l))}return}let a=0;s>=n[n.length-1]?a=n.length-1:a=ut.binarySearch(n,s,1)-1;const h=this.attachmentNames[a];t.slots[this.slotIndex].setAttachment(h==null?null:t.getAttachment(this.slotIndex,h))}},es=null,ar=class extends Ct{constructor(t){super(t),this.frames=C.newFloatArray(t),this.frameVertices=new Array(t),es==null&&(es=C.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,r,s){this.frames[t]=r,this.frameVertices[t]=s}apply(t,r,s,i,o,m,d){const e=t.slots[this.slotIndex],n=e.getAttachment();if(!(n instanceof fe)||!n.applyDeform(this.attachment))return;const a=e.attachmentVertices;a.length==0&&(m=R.setup);const h=this.frameVertices,l=h[0].length,u=this.frames;if(s<u[0]){const b=n;switch(m){case R.setup:a.length=0;return;case R.first:if(o==1){a.length=0;break}const y=C.setArraySize(a,l);if(b.bones==null){const S=b.vertices;for(let I=0;I<l;I++)y[I]+=(S[I]-y[I])*o}else{o=1-o;for(let S=0;S<l;S++)y[S]*=o}}return}const f=C.setArraySize(a,l);if(s>=u[u.length-1]){const b=h[u.length-1];if(o==1)if(m==R.add){const y=n;if(y.bones==null){const S=y.vertices;for(let I=0;I<l;I++)f[I]+=b[I]-S[I]}else for(let S=0;S<l;S++)f[S]+=b[S]}else C.arrayCopy(b,0,f,0,l);else switch(m){case R.setup:{const S=n;if(S.bones==null){const I=S.vertices;for(let v=0;v<l;v++){const M=I[v];f[v]=M+(b[v]-M)*o}}else for(let I=0;I<l;I++)f[I]=b[I]*o;break}case R.first:case R.replace:for(let S=0;S<l;S++)f[S]+=(b[S]-f[S])*o;case R.add:const y=n;if(y.bones==null){const S=y.vertices;for(let I=0;I<l;I++)f[I]+=(b[I]-S[I])*o}else for(let S=0;S<l;S++)f[S]+=b[S]*o}return}const g=ut.binarySearch(u,s),w=h[g-1],E=h[g],x=u[g],p=this.getCurvePercent(g-1,1-(s-x)/(u[g-1]-x));if(o==1)if(m==R.add){const b=n;if(b.bones==null){const y=b.vertices;for(let S=0;S<l;S++){const I=w[S];f[S]+=I+(E[S]-I)*p-y[S]}}else for(let y=0;y<l;y++){const S=w[y];f[y]+=S+(E[y]-S)*p}}else for(let b=0;b<l;b++){const y=w[b];f[b]=y+(E[b]-y)*p}else switch(m){case R.setup:{const y=n;if(y.bones==null){const S=y.vertices;for(let I=0;I<l;I++){const v=w[I],M=S[I];f[I]=M+(v+(E[I]-v)*p-M)*o}}else for(let S=0;S<l;S++){const I=w[S];f[S]=(I+(E[S]-I)*p)*o}break}case R.first:case R.replace:for(let y=0;y<l;y++){const S=w[y];f[y]+=(S+(E[y]-S)*p-f[y])*o}break;case R.add:const b=n;if(b.bones==null){const y=b.vertices;for(let S=0;S<l;S++){const I=w[S];f[S]+=(I+(E[S]-I)*p-y[S])*o}}else for(let y=0;y<l;y++){const S=w[y];f[y]+=(S+(E[y]-S)*p)*o}}}},ir=class{constructor(t){this.frames=C.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,r){this.frames[t]=r.time,this.events[t]=r}apply(t,r,s,i,o,m,d){if(i==null)return;const e=this.frames,n=this.frames.length;if(r>s)this.apply(t,r,Number.MAX_VALUE,i,o,m,d),r=-1;else if(r>=e[n-1])return;if(s<e[0])return;let a=0;if(r<e[0])a=0;else{a=ut.binarySearch(e,r);const h=e[a];for(;a>0&&e[a-1]==h;)a--}for(;a<n&&s>=e[a];a++)i.push(this.events[a])}},lr=class{constructor(t){this.frames=C.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,r,s){this.frames[t]=r,this.drawOrders[t]=s}apply(t,r,s,i,o,m,d){const e=t.drawOrder,n=t.slots;if(d==K.mixOut&&m==R.setup){C.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const a=this.frames;if(s<a[0]){(m==R.setup||m==R.first)&&C.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let h=0;s>=a[a.length-1]?h=a.length-1:h=ut.binarySearch(a,s)-1;const l=this.drawOrders[h];if(l==null)C.arrayCopy(n,0,e,0,n.length);else for(let u=0,f=l.length;u<f;u++)e[u]=n[l[u]]}};const G=class extends Ct{constructor(c){super(c),this.frames=C.newFloatArray(c*G.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(c,t,r,s,i,o){c*=G.ENTRIES,this.frames[c]=t,this.frames[c+G.MIX]=r,this.frames[c+G.BEND_DIRECTION]=s,this.frames[c+G.COMPRESS]=i?1:0,this.frames[c+G.STRETCH]=o?1:0}apply(c,t,r,s,i,o,m){const d=this.frames,e=c.ikConstraints[this.ikConstraintIndex];if(r<d[0]){switch(o){case R.setup:e.mix=e.data.mix,e.bendDirection=e.data.bendDirection,e.compress=e.data.compress,e.stretch=e.data.stretch;return;case R.first:e.mix+=(e.data.mix-e.mix)*i,e.bendDirection=e.data.bendDirection,e.compress=e.data.compress,e.stretch=e.data.stretch}return}if(r>=d[d.length-G.ENTRIES]){o==R.setup?(e.mix=e.data.mix+(d[d.length+G.PREV_MIX]-e.data.mix)*i,m==K.mixOut?(e.bendDirection=e.data.bendDirection,e.compress=e.data.compress,e.stretch=e.data.stretch):(e.bendDirection=d[d.length+G.PREV_BEND_DIRECTION],e.compress=d[d.length+G.PREV_COMPRESS]!=0,e.stretch=d[d.length+G.PREV_STRETCH]!=0)):(e.mix+=(d[d.length+G.PREV_MIX]-e.mix)*i,m==K.mixIn&&(e.bendDirection=d[d.length+G.PREV_BEND_DIRECTION],e.compress=d[d.length+G.PREV_COMPRESS]!=0,e.stretch=d[d.length+G.PREV_STRETCH]!=0));return}const n=ut.binarySearch(d,r,G.ENTRIES),a=d[n+G.PREV_MIX],h=d[n],l=this.getCurvePercent(n/G.ENTRIES-1,1-(r-h)/(d[n+G.PREV_TIME]-h));o==R.setup?(e.mix=e.data.mix+(a+(d[n+G.MIX]-a)*l-e.data.mix)*i,m==K.mixOut?(e.bendDirection=e.data.bendDirection,e.compress=e.data.compress,e.stretch=e.data.stretch):(e.bendDirection=d[n+G.PREV_BEND_DIRECTION],e.compress=d[n+G.PREV_COMPRESS]!=0,e.stretch=d[n+G.PREV_STRETCH]!=0)):(e.mix+=(a+(d[n+G.MIX]-a)*l-e.mix)*i,m==K.mixIn&&(e.bendDirection=d[n+G.PREV_BEND_DIRECTION],e.compress=d[n+G.PREV_COMPRESS]!=0,e.stretch=d[n+G.PREV_STRETCH]!=0))}};let Vt=G;Vt.ENTRIES=5;Vt.PREV_TIME=-5;Vt.PREV_MIX=-4;Vt.PREV_BEND_DIRECTION=-3;Vt.PREV_COMPRESS=-2;Vt.PREV_STRETCH=-1;Vt.MIX=1;Vt.BEND_DIRECTION=2;Vt.COMPRESS=3;Vt.STRETCH=4;const j=class extends Ct{constructor(c){super(c),this.frames=C.newFloatArray(c*j.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(c,t,r,s,i,o){c*=j.ENTRIES,this.frames[c]=t,this.frames[c+j.ROTATE]=r,this.frames[c+j.TRANSLATE]=s,this.frames[c+j.SCALE]=i,this.frames[c+j.SHEAR]=o}apply(c,t,r,s,i,o,m){const d=this.frames,e=c.transformConstraints[this.transformConstraintIndex];if(r<d[0]){const u=e.data;switch(o){case R.setup:e.rotateMix=u.rotateMix,e.translateMix=u.translateMix,e.scaleMix=u.scaleMix,e.shearMix=u.shearMix;return;case R.first:e.rotateMix+=(u.rotateMix-e.rotateMix)*i,e.translateMix+=(u.translateMix-e.translateMix)*i,e.scaleMix+=(u.scaleMix-e.scaleMix)*i,e.shearMix+=(u.shearMix-e.shearMix)*i}return}let n=0,a=0,h=0,l=0;if(r>=d[d.length-j.ENTRIES]){const u=d.length;n=d[u+j.PREV_ROTATE],a=d[u+j.PREV_TRANSLATE],h=d[u+j.PREV_SCALE],l=d[u+j.PREV_SHEAR]}else{const u=ut.binarySearch(d,r,j.ENTRIES);n=d[u+j.PREV_ROTATE],a=d[u+j.PREV_TRANSLATE],h=d[u+j.PREV_SCALE],l=d[u+j.PREV_SHEAR];const f=d[u],g=this.getCurvePercent(u/j.ENTRIES-1,1-(r-f)/(d[u+j.PREV_TIME]-f));n+=(d[u+j.ROTATE]-n)*g,a+=(d[u+j.TRANSLATE]-a)*g,h+=(d[u+j.SCALE]-h)*g,l+=(d[u+j.SHEAR]-l)*g}if(o==R.setup){const u=e.data;e.rotateMix=u.rotateMix+(n-u.rotateMix)*i,e.translateMix=u.translateMix+(a-u.translateMix)*i,e.scaleMix=u.scaleMix+(h-u.scaleMix)*i,e.shearMix=u.shearMix+(l-u.shearMix)*i}else e.rotateMix+=(n-e.rotateMix)*i,e.translateMix+=(a-e.translateMix)*i,e.scaleMix+=(h-e.scaleMix)*i,e.shearMix+=(l-e.shearMix)*i}};let Ft=j;Ft.ENTRIES=5;Ft.PREV_TIME=-5;Ft.PREV_ROTATE=-4;Ft.PREV_TRANSLATE=-3;Ft.PREV_SCALE=-2;Ft.PREV_SHEAR=-1;Ft.ROTATE=1;Ft.TRANSLATE=2;Ft.SCALE=3;Ft.SHEAR=4;const Lt=class extends Ct{constructor(c){super(c),this.frames=C.newFloatArray(c*Lt.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(c,t,r){c*=Lt.ENTRIES,this.frames[c]=t,this.frames[c+Lt.VALUE]=r}apply(c,t,r,s,i,o,m){const d=this.frames,e=c.pathConstraints[this.pathConstraintIndex];if(r<d[0]){switch(o){case R.setup:e.position=e.data.position;return;case R.first:e.position+=(e.data.position-e.position)*i}return}let n=0;if(r>=d[d.length-Lt.ENTRIES])n=d[d.length+Lt.PREV_VALUE];else{const a=ut.binarySearch(d,r,Lt.ENTRIES);n=d[a+Lt.PREV_VALUE];const h=d[a],l=this.getCurvePercent(a/Lt.ENTRIES-1,1-(r-h)/(d[a+Lt.PREV_TIME]-h));n+=(d[a+Lt.VALUE]-n)*l}o==R.setup?e.position=e.data.position+(n-e.data.position)*i:e.position+=(n-e.position)*i}};let he=Lt;he.ENTRIES=2;he.PREV_TIME=-2;he.PREV_VALUE=-1;he.VALUE=1;let cr=class ee extends he{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,r,s,i,o,m,d){const e=this.frames,n=t.pathConstraints[this.pathConstraintIndex];if(s<e[0]){switch(m){case R.setup:n.spacing=n.data.spacing;return;case R.first:n.spacing+=(n.data.spacing-n.spacing)*o}return}let a=0;if(s>=e[e.length-ee.ENTRIES])a=e[e.length+ee.PREV_VALUE];else{const h=ut.binarySearch(e,s,ee.ENTRIES);a=e[h+ee.PREV_VALUE];const l=e[h],u=this.getCurvePercent(h/ee.ENTRIES-1,1-(s-l)/(e[h+ee.PREV_TIME]-l));a+=(e[h+ee.VALUE]-a)*u}m==R.setup?n.spacing=n.data.spacing+(a-n.data.spacing)*o:n.spacing+=(a-n.spacing)*o}};const bt=class extends Ct{constructor(c){super(c),this.frames=C.newFloatArray(c*bt.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(c,t,r,s){c*=bt.ENTRIES,this.frames[c]=t,this.frames[c+bt.ROTATE]=r,this.frames[c+bt.TRANSLATE]=s}apply(c,t,r,s,i,o,m){const d=this.frames,e=c.pathConstraints[this.pathConstraintIndex];if(r<d[0]){switch(o){case R.setup:e.rotateMix=e.data.rotateMix,e.translateMix=e.data.translateMix;return;case R.first:e.rotateMix+=(e.data.rotateMix-e.rotateMix)*i,e.translateMix+=(e.data.translateMix-e.translateMix)*i}return}let n=0,a=0;if(r>=d[d.length-bt.ENTRIES])n=d[d.length+bt.PREV_ROTATE],a=d[d.length+bt.PREV_TRANSLATE];else{const h=ut.binarySearch(d,r,bt.ENTRIES);n=d[h+bt.PREV_ROTATE],a=d[h+bt.PREV_TRANSLATE];const l=d[h],u=this.getCurvePercent(h/bt.ENTRIES-1,1-(r-l)/(d[h+bt.PREV_TIME]-l));n+=(d[h+bt.ROTATE]-n)*u,a+=(d[h+bt.TRANSLATE]-a)*u}o==R.setup?(e.rotateMix=e.data.rotateMix+(n-e.data.rotateMix)*i,e.translateMix=e.data.translateMix+(a-e.data.translateMix)*i):(e.rotateMix+=(n-e.rotateMix)*i,e.translateMix+=(a-e.translateMix)*i)}};let ae=bt;ae.ENTRIES=3;ae.PREV_TIME=-3;ae.PREV_ROTATE=-2;ae.PREV_TRANSLATE=-1;ae.ROTATE=1;ae.TRANSLATE=2;new ut("<empty>",[],0);let hr=class{constructor(t){this.atlas=t}newRegionAttachment(t,r,s){const i=this.atlas.findRegion(s);if(i==null)throw new Error(`Region not found in atlas: ${s} (region attachment: ${r})`);const o=new X(r);return o.region=i,o}newMeshAttachment(t,r,s){const i=this.atlas.findRegion(s);if(i==null)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${r})`);const o=new Qn(r);return o.region=i,o}newBoundingBoxAttachment(t,r){return new Jn(r)}newPathAttachment(t,r){return new tr(r)}newPointAttachment(t,r){return new er(r)}newClippingAttachment(t,r){return new Kn(r)}},dr=class{constructor(t,r,s){if(this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=st.Normal,t<0)throw new Error("index must be >= 0.");if(r==null)throw new Error("name cannot be null.");this.index=t,this.name=r,this.parent=s}},ur=class{constructor(t,r){if(r==null)throw new Error("data cannot be null.");this.time=t,this.data=r}},fr=class{constructor(t){this.name=t}},mr=class{constructor(t){this.order=0,this.bones=new Array,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.name=t}},gr=class{constructor(t){this.order=0,this.bones=new Array,this.name=t}};var se=(c=>(c[c.Length=0]="Length",c[c.Fixed=1]="Fixed",c[c.Percent=2]="Percent",c))(se||{});let wr=class{constructor(){this.bones=new Array,this.slots=new Array,this.skins=new Array,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.fps=0}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const r=this.bones;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const r=this.bones;for(let s=0,i=r.length;s<i;s++)if(r[s].name==t)return s;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const r=this.slots;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const r=this.slots;for(let s=0,i=r.length;s<i;s++)if(r[s].name==t)return s;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const r=this.skins;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const r=this.events;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const r=this.animations;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const r=this.ikConstraints;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const r=this.transformConstraints;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const r=this.pathConstraints;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const r=this.pathConstraints;for(let s=0,i=r.length;s<i;s++)if(r[s].name==t)return s;return-1}},xr=class{constructor(t,r,s){if(this.color=new T(1,1,1,1),t<0)throw new Error("index must be >= 0.");if(r==null)throw new Error("name cannot be null.");if(s==null)throw new Error("boneData cannot be null.");this.index=t,this.name=r,this.boneData=s}},Er=class{constructor(t){if(this.order=0,this.bones=new Array,this.rotateMix=0,this.translateMix=0,this.scaleMix=0,this.shearMix=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1,t==null)throw new Error("name cannot be null.");this.name=t}},br=class{constructor(t){if(this.attachments=new Array,t==null)throw new Error("name cannot be null.");this.name=t}addAttachment(t,r,s){if(s==null)throw new Error("attachment cannot be null.");const i=this.attachments;t>=i.length&&(i.length=t+1),i[t]||(i[t]={}),i[t][r]=s}getAttachment(t,r){const s=this.attachments[t];return s?s[r]:null}attachAll(t,r){let s=0;for(let i=0;i<t.slots.length;i++){const o=t.slots[i],m=o.getAttachment();if(m&&s<r.attachments.length){const d=r.attachments[s];for(const e in d){const n=d[e];if(m==n){const a=this.getAttachment(s,e);a!=null&&o.setAttachment(a);break}}}s++}}},pr=class we{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const r=this.scale,s=new wr,i=typeof t=="string"?JSON.parse(t):t,o=i.skeleton;if(o!=null&&(s.hash=o.hash,s.version=o.spine,s.width=o.width,s.height=o.height,s.fps=o.fps,s.imagesPath=o.images),i.bones)for(let m=0;m<i.bones.length;m++){const d=i.bones[m];let e=null;const n=this.getValue(d,"parent",null);if(n!=null&&(e=s.findBone(n),e==null))throw new Error(`Parent bone not found: ${n}`);const a=new dr(s.bones.length,d.name,e);a.length=this.getValue(d,"length",0)*r,a.x=this.getValue(d,"x",0)*r,a.y=this.getValue(d,"y",0)*r,a.rotation=this.getValue(d,"rotation",0),a.scaleX=this.getValue(d,"scaleX",1),a.scaleY=this.getValue(d,"scaleY",1),a.shearX=this.getValue(d,"shearX",0),a.shearY=this.getValue(d,"shearY",0),a.transformMode=we.transformModeFromString(this.getValue(d,"transform","normal")),s.bones.push(a)}if(i.slots)for(let m=0;m<i.slots.length;m++){const d=i.slots[m],e=d.name,n=d.bone,a=s.findBone(n);if(a==null)throw new Error(`Slot bone not found: ${n}`);const h=new xr(s.slots.length,e,a),l=this.getValue(d,"color",null);l!=null&&h.color.setFromString(l);const u=this.getValue(d,"dark",null);u!=null&&(h.darkColor=new T(1,1,1,1),h.darkColor.setFromString(u)),h.attachmentName=this.getValue(d,"attachment",null),h.blendMode=we.blendModeFromString(this.getValue(d,"blend","normal")),s.slots.push(h)}if(i.ik)for(let m=0;m<i.ik.length;m++){const d=i.ik[m],e=new mr(d.name);e.order=this.getValue(d,"order",0);for(let a=0;a<d.bones.length;a++){const h=d.bones[a],l=s.findBone(h);if(l==null)throw new Error(`IK bone not found: ${h}`);e.bones.push(l)}const n=d.target;if(e.target=s.findBone(n),e.target==null)throw new Error(`IK target bone not found: ${n}`);e.bendDirection=this.getValue(d,"bendPositive",!0)?1:-1,e.mix=this.getValue(d,"mix",1),s.ikConstraints.push(e)}if(i.transform)for(let m=0;m<i.transform.length;m++){const d=i.transform[m],e=new Er(d.name);e.order=this.getValue(d,"order",0);for(let a=0;a<d.bones.length;a++){const h=d.bones[a],l=s.findBone(h);if(l==null)throw new Error(`Transform constraint bone not found: ${h}`);e.bones.push(l)}const n=d.target;if(e.target=s.findBone(n),e.target==null)throw new Error(`Transform constraint target bone not found: ${n}`);e.local=this.getValue(d,"local",!1),e.relative=this.getValue(d,"relative",!1),e.offsetRotation=this.getValue(d,"rotation",0),e.offsetX=this.getValue(d,"x",0)*r,e.offsetY=this.getValue(d,"y",0)*r,e.offsetScaleX=this.getValue(d,"scaleX",0),e.offsetScaleY=this.getValue(d,"scaleY",0),e.offsetShearY=this.getValue(d,"shearY",0),e.rotateMix=this.getValue(d,"rotateMix",1),e.translateMix=this.getValue(d,"translateMix",1),e.scaleMix=this.getValue(d,"scaleMix",1),e.shearMix=this.getValue(d,"shearMix",1),s.transformConstraints.push(e)}if(i.path)for(let m=0;m<i.path.length;m++){const d=i.path[m],e=new gr(d.name);e.order=this.getValue(d,"order",0);for(let a=0;a<d.bones.length;a++){const h=d.bones[a],l=s.findBone(h);if(l==null)throw new Error(`Transform constraint bone not found: ${h}`);e.bones.push(l)}const n=d.target;if(e.target=s.findSlot(n),e.target==null)throw new Error(`Path target slot not found: ${n}`);e.positionMode=we.positionModeFromString(this.getValue(d,"positionMode","percent")),e.spacingMode=we.spacingModeFromString(this.getValue(d,"spacingMode","length")),e.rotateMode=we.rotateModeFromString(this.getValue(d,"rotateMode","tangent")),e.offsetRotation=this.getValue(d,"rotation",0),e.position=this.getValue(d,"position",0),e.positionMode==at.Fixed&&(e.position*=r),e.spacing=this.getValue(d,"spacing",0),(e.spacingMode==se.Length||e.spacingMode==se.Fixed)&&(e.spacing*=r),e.rotateMix=this.getValue(d,"rotateMix",1),e.translateMix=this.getValue(d,"translateMix",1),s.pathConstraints.push(e)}if(i.skins)for(const m in i.skins){const d=i.skins[m],e=new br(m);for(const n in d){const a=s.findSlotIndex(n);if(a==-1)throw new Error(`Slot not found: ${n}`);const h=d[n];for(const l in h){const u=this.readAttachment(h[l],e,a,l,s);u!=null&&e.addAttachment(a,l,u)}}s.skins.push(e),e.name=="default"&&(s.defaultSkin=e)}for(let m=0,d=this.linkedMeshes.length;m<d;m++){const e=this.linkedMeshes[m],n=e.skin==null?s.defaultSkin:s.findSkin(e.skin);if(n==null)throw new Error(`Skin not found: ${e.skin}`);const a=n.getAttachment(e.slotIndex,e.parent);if(a==null)throw new Error(`Parent mesh not found: ${e.parent}`);e.mesh.setParentMesh(a)}if(this.linkedMeshes.length=0,i.events)for(const m in i.events){const d=i.events[m],e=new fr(m);e.intValue=this.getValue(d,"int",0),e.floatValue=this.getValue(d,"float",0),e.stringValue=this.getValue(d,"string",""),e.audioPath=this.getValue(d,"audio",null),e.audioPath!=null&&(e.volume=this.getValue(d,"volume",1),e.balance=this.getValue(d,"balance",0)),s.events.push(e)}if(i.animations)for(const m in i.animations){const d=i.animations[m];this.readAnimation(d,m,s)}return s}readAttachment(t,r,s,i,o){const m=this.scale;switch(i=this.getValue(t,"name",i),this.getValue(t,"type","region")){case"region":{const e=this.getValue(t,"path",i),n=this.attachmentLoader.newRegionAttachment(r,i,e);if(n==null)return null;n.path=e,n.x=this.getValue(t,"x",0)*m,n.y=this.getValue(t,"y",0)*m,n.scaleX=this.getValue(t,"scaleX",1),n.scaleY=this.getValue(t,"scaleY",1),n.rotation=this.getValue(t,"rotation",0),n.width=t.width*m,n.height=t.height*m;const a=this.getValue(t,"color",null);return a!=null&&n.color.setFromString(a),n}case"boundingbox":{const e=this.attachmentLoader.newBoundingBoxAttachment(r,i);if(e==null)return null;this.readVertices(t,e,t.vertexCount<<1);const n=this.getValue(t,"color",null);return n!=null&&e.color.setFromString(n),e}case"mesh":case"linkedmesh":{const e=this.getValue(t,"path",i),n=this.attachmentLoader.newMeshAttachment(r,i,e);if(n==null)return null;n.path=e;const a=this.getValue(t,"color",null);a!=null&&n.color.setFromString(a);const h=this.getValue(t,"parent",null);if(h!=null)return n.inheritDeform=this.getValue(t,"deform",!0),this.linkedMeshes.push(new yr(n,this.getValue(t,"skin",null),s,h)),n;const l=t.uvs;return this.readVertices(t,n,l.length),n.triangles=t.triangles,n.regionUVs=new Float32Array(l),n.hullLength=this.getValue(t,"hull",0)*2,n}case"path":{const e=this.attachmentLoader.newPathAttachment(r,i);if(e==null)return null;e.closed=this.getValue(t,"closed",!1),e.constantSpeed=this.getValue(t,"constantSpeed",!0);const n=t.vertexCount;this.readVertices(t,e,n<<1);const a=C.newArray(n/3,0);for(let l=0;l<t.lengths.length;l++)a[l]=t.lengths[l]*m;e.lengths=a;const h=this.getValue(t,"color",null);return h!=null&&e.color.setFromString(h),e}case"point":{const e=this.attachmentLoader.newPointAttachment(r,i);if(e==null)return null;e.x=this.getValue(t,"x",0)*m,e.y=this.getValue(t,"y",0)*m,e.rotation=this.getValue(t,"rotation",0);const n=this.getValue(t,"color",null);return n!=null&&e.color.setFromString(n),e}case"clipping":{const e=this.attachmentLoader.newClippingAttachment(r,i);if(e==null)return null;const n=this.getValue(t,"end",null);if(n!=null){const l=o.findSlot(n);if(l==null)throw new Error(`Clipping end slot not found: ${n}`);e.endSlot=l}const a=t.vertexCount;this.readVertices(t,e,a<<1);const h=this.getValue(t,"color",null);return h!=null&&e.color.setFromString(h),e}}return null}readVertices(t,r,s){const i=this.scale;r.worldVerticesLength=s;const o=t.vertices;if(s==o.length){const e=C.toFloatArray(o);if(i!=1)for(let n=0,a=o.length;n<a;n++)e[n]*=i;r.vertices=e;return}const m=new Array,d=new Array;for(let e=0,n=o.length;e<n;){const a=o[e++];d.push(a);for(let h=e+a*4;e<h;e+=4)d.push(o[e]),m.push(o[e+1]*i),m.push(o[e+2]*i),m.push(o[e+3])}r.bones=d,r.vertices=C.toFloatArray(m)}readAnimation(t,r,s){const i=this.scale,o=new Array;let m=0;if(t.slots)for(const e in t.slots){const n=t.slots[e],a=s.findSlotIndex(e);if(a==-1)throw new Error(`Slot not found: ${e}`);for(const h in n){const l=n[h];if(h=="attachment"){const u=new or(l.length);u.slotIndex=a;let f=0;for(let g=0;g<l.length;g++){const w=l[g];u.setFrame(f++,w.time,w.name)}o.push(u),m=Math.max(m,u.frames[u.getFrameCount()-1])}else if(h=="color"){const u=new Mt(l.length);u.slotIndex=a;let f=0;for(let g=0;g<l.length;g++){const w=l[g],E=new T;E.setFromString(w.color||"ffffffff"),u.setFrame(f,w.time,E.r,E.g,E.b,E.a),this.readCurve(w,u,f),f++}o.push(u),m=Math.max(m,u.frames[(u.getFrameCount()-1)*Mt.ENTRIES])}else if(h=="twoColor"){const u=new ct(l.length);u.slotIndex=a;let f=0;for(let g=0;g<l.length;g++){const w=l[g],E=new T,x=new T;E.setFromString(w.light),x.setFromString(w.dark),u.setFrame(f,w.time,E.r,E.g,E.b,E.a,x.r,x.g,x.b),this.readCurve(w,u,f),f++}o.push(u),m=Math.max(m,u.frames[(u.getFrameCount()-1)*ct.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${h} (${e})`)}}if(t.bones)for(const e in t.bones){const n=t.bones[e],a=s.findBoneIndex(e);if(a==-1)throw new Error(`Bone not found: ${e}`);for(const h in n){const l=n[h];if(h==="rotate"){const u=new Ee(l.length);u.boneIndex=a;let f=0;for(let g=0;g<l.length;g++){const w=l[g];u.setFrame(f,w.time,w.angle),this.readCurve(w,u,f),f++}o.push(u),m=Math.max(m,u.frames[(u.getFrameCount()-1)*Ee.ENTRIES])}else if(h==="translate"||h==="scale"||h==="shear"){let u=null,f=1;h==="scale"?u=new nr(l.length):h==="shear"?u=new rr(l.length):(u=new zt(l.length),f=i),u.boneIndex=a;let g=0;for(let w=0;w<l.length;w++){const E=l[w],x=this.getValue(E,"x",0),p=this.getValue(E,"y",0);u.setFrame(g,E.time,x*f,p*f),this.readCurve(E,u,g),g++}o.push(u),m=Math.max(m,u.frames[(u.getFrameCount()-1)*zt.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${h} (${e})`)}}if(t.ik)for(const e in t.ik){const n=t.ik[e],a=s.findIkConstraint(e),h=new Vt(n.length);h.ikConstraintIndex=s.ikConstraints.indexOf(a);let l=0;for(let u=0;u<n.length;u++){const f=n[u];h.setFrame(l,f.time,this.getValue(f,"mix",1),this.getValue(f,"bendPositive",!0)?1:-1,this.getValue(f,"compress",!1),this.getValue(f,"stretch",!1)),this.readCurve(f,h,l),l++}o.push(h),m=Math.max(m,h.frames[(h.getFrameCount()-1)*Vt.ENTRIES])}if(t.transform)for(const e in t.transform){const n=t.transform[e],a=s.findTransformConstraint(e),h=new Ft(n.length);h.transformConstraintIndex=s.transformConstraints.indexOf(a);let l=0;for(let u=0;u<n.length;u++){const f=n[u];h.setFrame(l,f.time,this.getValue(f,"rotateMix",1),this.getValue(f,"translateMix",1),this.getValue(f,"scaleMix",1),this.getValue(f,"shearMix",1)),this.readCurve(f,h,l),l++}o.push(h),m=Math.max(m,h.frames[(h.getFrameCount()-1)*Ft.ENTRIES])}if(t.paths)for(const e in t.paths){const n=t.paths[e],a=s.findPathConstraintIndex(e);if(a==-1)throw new Error(`Path constraint not found: ${e}`);const h=s.pathConstraints[a];for(const l in n){const u=n[l];if(l==="position"||l==="spacing"){let f=null,g=1;l==="spacing"?(f=new cr(u.length),(h.spacingMode==se.Length||h.spacingMode==se.Fixed)&&(g=i)):(f=new he(u.length),h.positionMode==at.Fixed&&(g=i)),f.pathConstraintIndex=a;let w=0;for(let E=0;E<u.length;E++){const x=u[E];f.setFrame(w,x.time,this.getValue(x,l,0)*g),this.readCurve(x,f,w),w++}o.push(f),m=Math.max(m,f.frames[(f.getFrameCount()-1)*he.ENTRIES])}else if(l==="mix"){const f=new ae(u.length);f.pathConstraintIndex=a;let g=0;for(let w=0;w<u.length;w++){const E=u[w];f.setFrame(g,E.time,this.getValue(E,"rotateMix",1),this.getValue(E,"translateMix",1)),this.readCurve(E,f,g),g++}o.push(f),m=Math.max(m,f.frames[(f.getFrameCount()-1)*ae.ENTRIES])}}}if(t.deform)for(const e in t.deform){const n=t.deform[e],a=s.findSkin(e);if(a!=null)for(const h in n){const l=n[h],u=s.findSlotIndex(h);if(u==-1)throw new Error(`Slot not found: ${l.name}`);for(const f in l){const g=l[f],w=a.getAttachment(u,f);if(w==null)throw new Error(`Deform attachment not found: ${g.name}`);const E=w.bones!=null,x=w.vertices,p=E?x.length/3*2:x.length,b=new ar(g.length);b.slotIndex=u,b.attachment=w;let y=0;for(let S=0;S<g.length;S++){const I=g[S];let v;const M=this.getValue(I,"vertices",null);if(M==null)v=E?C.newFloatArray(p):x;else{v=C.newFloatArray(p);const P=this.getValue(I,"offset",0);if(C.arrayCopy(M,0,v,P,M.length),i!=1)for(let V=P,k=V+M.length;V<k;V++)v[V]*=i;if(!E)for(let V=0;V<p;V++)v[V]+=x[V]}b.setFrame(y,I.time,v),this.readCurve(I,b,y),y++}o.push(b),m=Math.max(m,b.frames[b.getFrameCount()-1])}}}let d=t.drawOrder;if(d==null&&(d=t.draworder),d!=null){const e=new lr(d.length),n=s.slots.length;let a=0;for(let h=0;h<d.length;h++){const l=d[h];let u=null;const f=this.getValue(l,"offsets",null);if(f!=null){u=C.newArray(n,-1);const g=C.newArray(n-f.length,0);let w=0,E=0;for(let x=0;x<f.length;x++){const p=f[x],b=s.findSlotIndex(p.slot);if(b==-1)throw new Error(`Slot not found: ${p.slot}`);for(;w!=b;)g[E++]=w++;u[w+p.offset]=w++}for(;w<n;)g[E++]=w++;for(let x=n-1;x>=0;x--)u[x]==-1&&(u[x]=g[--E])}e.setFrame(a++,l.time,u)}o.push(e),m=Math.max(m,e.frames[e.getFrameCount()-1])}if(t.events){const e=new ir(t.events.length);let n=0;for(let a=0;a<t.events.length;a++){const h=t.events[a],l=s.findEvent(h.name);if(l==null)throw new Error(`Event not found: ${h.name}`);const u=new ur(C.toSinglePrecision(h.time),l);u.intValue=this.getValue(h,"int",l.intValue),u.floatValue=this.getValue(h,"float",l.floatValue),u.stringValue=this.getValue(h,"string",l.stringValue),u.data.audioPath!=null&&(u.volume=this.getValue(h,"volume",1),u.balance=this.getValue(h,"balance",0)),e.setFrame(n++,u)}o.push(e),m=Math.max(m,e.frames[e.getFrameCount()-1])}if(isNaN(m))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new ut(r,o,m))}readCurve(t,r,s){if(t.curve){if(t.curve==="stepped")r.setStepped(s);else if(Object.prototype.toString.call(t.curve)==="[object Array]"){const i=t.curve;r.setCurve(s,i[0],i[1],i[2],i[3])}}}getValue(t,r,s){return t[r]!==void 0?t[r]:s}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return et.NORMAL;if(t=="additive")return et.ADD;if(t=="multiply")return et.MULTIPLY;if(t=="screen")return et.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return at.Fixed;if(t=="percent")return at.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return se.Length;if(t=="fixed")return se.Fixed;if(t=="percent")return se.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return vt.Tangent;if(t=="chain")return vt.Chain;if(t=="chainscale")return vt.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return st.Normal;if(t=="onlytranslation")return st.OnlyTranslation;if(t=="norotationorreflection")return st.NoRotationOrReflection;if(t=="noscale")return st.NoScale;if(t=="noscaleorreflection")return st.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}},yr=class{constructor(t,r,s,i){this.mesh=t,this.skin=r,this.slotIndex=s,this.parent=i}};class Xs{constructor(t){if(!t)throw new Error("name cannot be null.");this.name=t}}const Bs=class extends Xs{constructor(c){super(c),this.id=Bs.nextID++,this.bones=null,this.vertices=[],this.worldVerticesLength=0,this.timelineAttachment=this}computeWorldVerticesOld(c,t){this.computeWorldVertices(c,0,this.worldVerticesLength,t,0,2)}computeWorldVertices(c,t,r,s,i,o){r=i+(r>>1)*o;const m=c.bone.skeleton,d=c.deform;let e=this.vertices;const n=this.bones;if(!n){d.length>0&&(e=d);const u=c.bone.matrix,f=u.tx,g=u.ty,w=u.a,E=u.c,x=u.b,p=u.d;for(let b=t,y=i;y<r;b+=2,y+=o){const S=e[b],I=e[b+1];s[y]=S*w+I*E+f,s[y+1]=S*x+I*p+g}return}let a=0,h=0;for(let u=0;u<t;u+=2){const f=n[a];a+=f+1,h+=f}const l=m.bones;if(d.length==0)for(let u=i,f=h*3;u<r;u+=o){let g=0,w=0,E=n[a++];for(E+=a;a<E;a++,f+=3){const x=l[n[a]].matrix,p=e[f],b=e[f+1],y=e[f+2];g+=(p*x.a+b*x.c+x.tx)*y,w+=(p*x.b+b*x.d+x.ty)*y}s[u]=g,s[u+1]=w}else{const u=d;for(let f=i,g=h*3,w=h<<1;f<r;f+=o){let E=0,x=0,p=n[a++];for(p+=a;a<p;a++,g+=3,w+=2){const b=l[n[a]].matrix,y=e[g]+u[w],S=e[g+1]+u[w+1],I=e[g+2];E+=(y*b.a+S*b.c+b.tx)*I,x+=(y*b.b+S*b.d+b.ty)*I}s[f]=E,s[f+1]=x}}}copyTo(c){this.bones?(c.bones=new Array(this.bones.length),C.arrayCopy(this.bones,0,c.bones,0,this.bones.length)):c.bones=null,this.vertices&&(c.vertices=C.newFloatArray(this.vertices.length),C.arrayCopy(this.vertices,0,c.vertices,0,this.vertices.length)),c.worldVerticesLength=this.worldVerticesLength,c.timelineAttachment=this.timelineAttachment}};let ie=Bs;ie.nextID=0;class Le extends ie{constructor(t){super(t),this.type=B.BoundingBox,this.color=new T(1,1,1,1)}copy(){const t=new Le(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}class Oe extends ie{constructor(t){super(t),this.type=B.Clipping,this.endSlot=null,this.color=new T(.2275,.2275,.8078,1)}copy(){const t=new Oe(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}class be extends ie{constructor(t,r){super(t),this.type=B.Mesh,this.region=null,this.triangles=[],this.color=new T(1,1,1,1),this.width=0,this.height=0,this.hullLength=0,this.edges=[],this.parentMesh=null,this.sequence=null,this.tempColor=new T(0,0,0,0),this.path=r}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new be(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),C.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),C.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,t.sequence=this.sequence!=null?this.sequence.copy():null,this.edges&&(t.edges=new Array(this.edges.length),C.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}computeWorldVertices(t,r,s,i,o,m){this.sequence!=null&&this.sequence.apply(t,this),super.computeWorldVertices(t,r,s,i,o,m)}newLinkedMesh(){const t=new be(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),t.timelineAttachment=this.timelineAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}}class _e extends ie{constructor(t){super(t),this.type=B.Path,this.lengths=[],this.closed=!1,this.constantSpeed=!1,this.color=new T(1,1,1,1)}copy(){const t=new _e(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),C.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}class $e extends ie{constructor(t){super(t),this.type=B.Point,this.x=0,this.y=0,this.rotation=0,this.color=new T(.38,.94,0,1)}computeWorldPosition(t,r){const s=t.matrix;return r.x=this.x*s.a+this.y*s.c+t.worldX,r.y=this.x*s.b+this.y*s.d+t.worldY,r}computeWorldRotation(t){const r=t.matrix,s=F.cosDeg(this.rotation),i=F.sinDeg(this.rotation),o=s*r.a+i*r.c,m=s*r.b+i*r.d;return Math.atan2(m,o)*F.radDeg}copy(){const t=new $e(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}const Ls=class extends Xs{constructor(c,t){super(c),this.type=B.Region,this.x=0,this.y=0,this.scaleX=1,this.scaleY=1,this.rotation=0,this.width=0,this.height=0,this.color=new T(1,1,1,1),this.rendererObject=null,this.region=null,this.sequence=null,this.offset=C.newFloatArray(8),this.uvs=C.newFloatArray(8),this.tempColor=new T(1,1,1,1),this.path=t}updateRegion(){if(!this.region)throw new Error("Region not set.");const c=this.region,t=this.width/this.region.originalWidth*this.scaleX,r=this.height/this.region.originalHeight*this.scaleY,s=-this.width/2*this.scaleX+this.region.offsetX*t,i=-this.height/2*this.scaleY+this.region.offsetY*r,o=s+this.region.width*t,m=i+this.region.height*r,d=this.rotation*Math.PI/180,e=Math.cos(d),n=Math.sin(d),a=this.x,h=this.y,l=s*e+a,u=s*n,f=i*e+h,g=i*n,w=o*e+a,E=o*n,x=m*e+h,p=m*n,b=this.offset;b[0]=l-g,b[1]=f+u,b[2]=l-p,b[3]=x+u,b[4]=w-p,b[5]=x+E,b[6]=w-g,b[7]=f+E;const y=this.uvs;c.degrees==90?(y[2]=c.u,y[3]=c.v2,y[4]=c.u,y[5]=c.v,y[6]=c.u2,y[7]=c.v,y[0]=c.u2,y[1]=c.v2):(y[0]=c.u,y[1]=c.v2,y[2]=c.u,y[3]=c.v,y[4]=c.u2,y[5]=c.v,y[6]=c.u2,y[7]=c.v2)}computeWorldVertices(c,t,r,s){this.sequence!=null&&this.sequence.apply(c,this);const i=c.bone,o=this.offset,m=i.matrix,d=m.tx,e=m.ty,n=m.a,a=m.c,h=m.b,l=m.d;let u=0,f=0;u=o[0],f=o[1],t[r]=u*n+f*a+d,t[r+1]=u*h+f*l+e,r+=s,u=o[2],f=o[3],t[r]=u*n+f*a+d,t[r+1]=u*h+f*l+e,r+=s,u=o[4],f=o[5],t[r]=u*n+f*a+d,t[r+1]=u*h+f*l+e,r+=s,u=o[6],f=o[7],t[r]=u*n+f*a+d,t[r+1]=u*h+f*l+e}copy(){const c=new Ls(this.name,this.path);return c.region=this.region,c.rendererObject=this.rendererObject,c.x=this.x,c.y=this.y,c.scaleX=this.scaleX,c.scaleY=this.scaleY,c.rotation=this.rotation,c.width=this.width,c.height=this.height,C.arrayCopy(this.uvs,0,c.uvs,0,8),C.arrayCopy(this.offset,0,c.offset,0,8),c.color.setFromColor(this.color),c.sequence=this.sequence!=null?this.sequence.copy():null,c}};let U=Ls;U.X1=0;U.Y1=1;U.C1R=2;U.C1G=3;U.C1B=4;U.C1A=5;U.U1=6;U.V1=7;U.X2=8;U.Y2=9;U.C2R=10;U.C2G=11;U.C2B=12;U.C2A=13;U.U2=14;U.V2=15;U.X3=16;U.Y3=17;U.C3R=18;U.C3G=19;U.C3B=20;U.C3A=21;U.U3=22;U.V3=23;U.X4=24;U.Y4=25;U.C4R=26;U.C4G=27;U.C4B=28;U.C4A=29;U.U4=30;U.V4=31;const Ie=class{constructor(c){this.id=Ie.nextID(),this.start=0,this.digits=0,this.setupIndex=0,this.regions=new Array(c)}copy(){const c=new Ie(this.regions.length);return C.arrayCopy(this.regions,0,c.regions,0,this.regions.length),c.start=this.start,c.digits=this.digits,c.setupIndex=this.setupIndex,c}apply(c,t){let r=c.sequenceIndex;r==-1&&(r=this.setupIndex),r>=this.regions.length&&(r=this.regions.length-1);const s=this.regions[r];t.region!=s&&(t.region=s)}getPath(c,t){let r=c;const s=(this.start+t).toString();for(let i=this.digits-s.length;i>0;i--)r+="0";return r+=s,r}static nextID(){return Ie._nextID++}};let De=Ie;De._nextID=0;var Wt=(c=>(c[c.hold=0]="hold",c[c.once=1]="once",c[c.loop=2]="loop",c[c.pingpong=3]="pingpong",c[c.onceReverse=4]="onceReverse",c[c.loopReverse=5]="loopReverse",c[c.pingpongReverse=6]="pingpongReverse",c))(Wt||{});const Os=[0,1,2,3,4,5,6];class Ue{constructor(t,r,s){if(this.timelines=[],this.timelineIds=new kn,!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(r),this.duration=s}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds.clear();for(let r=0;r<t.length;r++)this.timelineIds.addAll(t[r].getPropertyIds())}hasTimeline(t){for(let r=0;r<t.length;r++)if(this.timelineIds.contains(t[r]))return!0;return!1}apply(t,r,s,i,o,m,d,e){if(!t)throw new Error("skeleton cannot be null.");i&&this.duration!=0&&(s%=this.duration,r>0&&(r%=this.duration));const n=this.timelines;for(let a=0,h=n.length;a<h;a++)n[a].apply(t,r,s,o,m,d,e)}}const z={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,rgb:7,alpha:8,rgb2:9,attachment:10,deform:11,event:12,drawOrder:13,ikConstraint:14,transformConstraint:15,pathConstraintPosition:16,pathConstraintSpacing:17,pathConstraintMix:18,sequence:19};class rt{constructor(t,r){this.propertyIds=r,this.frames=C.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,r){const s=t.length;for(let i=1;i<s;i++)if(t[i]>r)return i-1;return s-1}static search(t,r,s){const i=t.length;for(let o=s;o<i;o+=s)if(t[o]>r)return o-s;return i-s}}class Gt extends rt{constructor(t,r,s){super(t,s),this.curves=C.newFloatArray(t+r*18),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const r=this.getFrameCount()+t*18;if(this.curves.length>r){const s=C.newFloatArray(r);C.arrayCopy(this.curves,0,s,0,r),this.curves=s}}setBezier(t,r,s,i,o,m,d,e,n,a,h){const l=this.curves;let u=this.getFrameCount()+t*18;s==0&&(l[r]=2+u);const f=(i-m*2+e)*.03,g=(o-d*2+n)*.03,w=((m-e)*3-i+a)*.006,E=((d-n)*3-o+h)*.006;let x=f*2+w,p=g*2+E,b=(m-i)*.3+f+w*.16666667,y=(d-o)*.3+g+E*.16666667,S=i+b,I=o+y;for(let v=u+18;u<v;u+=2)l[u]=S,l[u+1]=I,b+=x,y+=p,x+=w,p+=E,S+=b,I+=y}getBezierValue(t,r,s,i){const o=this.curves;if(o[i]>t){const n=this.frames[r],a=this.frames[r+s];return a+(t-n)/(o[i]-n)*(o[i+1]-a)}const m=i+18;for(i+=2;i<m;i+=2)if(o[i]>=t){const n=o[i-2],a=o[i-1];return a+(t-n)/(o[i]-n)*(o[i+1]-a)}r+=this.getFrameEntries();const d=o[m-2],e=o[m-1];return e+(t-d)/(this.frames[r]-d)*(this.frames[r+s]-e)}}class Ht extends Gt{constructor(t,r,s){super(t,r,[s])}getFrameEntries(){return 2}setFrame(t,r,s){t<<=1,this.frames[t]=r,this.frames[t+1]=s}getCurveValue(t){const r=this.frames;let s=r.length-2;for(let o=2;o<=s;o+=2)if(r[o]>t){s=o-2;break}const i=this.curves[s>>1];switch(i){case 0:const o=r[s],m=r[s+1];return m+(t-o)/(r[s+2]-o)*(r[s+2+1]-m);case 1:return r[s+1]}return this.getBezierValue(t,s,1,i-2)}}class ze extends Gt{constructor(t,r,s,i){super(t,r,[s,i])}getFrameEntries(){return 3}setFrame(t,r,s,i){t*=3,this.frames[t]=r,this.frames[t+1]=s,this.frames[t+2]=i}}class _s extends Ht{constructor(t,r,s){super(t,r,`${z.rotate}|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,r,s,i,o,m,d){const e=t.bones[this.boneIndex];if(!e.active)return;const n=this.frames;if(s<n[0]){switch(m){case R.setup:e.rotation=e.data.rotation;return;case R.first:e.rotation+=(e.data.rotation-e.rotation)*o}return}let a=this.getCurveValue(s);switch(m){case R.setup:e.rotation=e.data.rotation+a*o;break;case R.first:case R.replace:a+=e.data.rotation-e.rotation;case R.add:e.rotation+=a*o}}}class $s extends ze{constructor(t,r,s){super(t,r,`${z.x}|${s}`,`${z.y}|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,r,s,i,o,m,d){const e=t.bones[this.boneIndex];if(!e.active)return;const n=this.frames;if(s<n[0]){switch(m){case R.setup:e.x=e.data.x,e.y=e.data.y;return;case R.first:e.x+=(e.data.x-e.x)*o,e.y+=(e.data.y-e.y)*o}return}let a=0,h=0;const l=rt.search(n,s,3),u=this.curves[l/3];switch(u){case 0:const f=n[l];a=n[l+1],h=n[l+2];const g=(s-f)/(n[l+3]-f);a+=(n[l+3+1]-a)*g,h+=(n[l+3+2]-h)*g;break;case 1:a=n[l+1],h=n[l+2];break;default:a=this.getBezierValue(s,l,1,u-2),h=this.getBezierValue(s,l,2,u+18-2)}switch(m){case R.setup:e.x=e.data.x+a*o,e.y=e.data.y+h*o;break;case R.first:case R.replace:e.x+=(e.data.x+a-e.x)*o,e.y+=(e.data.y+h-e.y)*o;break;case R.add:e.x+=a*o,e.y+=h*o}}}class Ds extends Ht{constructor(t,r,s){super(t,r,`${z.x}|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,r,s,i,o,m,d){const e=t.bones[this.boneIndex];if(!e.active)return;const n=this.frames;if(s<n[0]){switch(m){case R.setup:e.x=e.data.x;return;case R.first:e.x+=(e.data.x-e.x)*o}return}const a=this.getCurveValue(s);switch(m){case R.setup:e.x=e.data.x+a*o;break;case R.first:case R.replace:e.x+=(e.data.x+a-e.x)*o;break;case R.add:e.x+=a*o}}}class Us extends Ht{constructor(t,r,s){super(t,r,`${z.y}|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,r,s,i,o,m,d){const e=t.bones[this.boneIndex];if(!e.active)return;const n=this.frames;if(s<n[0]){switch(m){case R.setup:e.y=e.data.y;return;case R.first:e.y+=(e.data.y-e.y)*o}return}const a=this.getCurveValue(s);switch(m){case R.setup:e.y=e.data.y+a*o;break;case R.first:case R.replace:e.y+=(e.data.y+a-e.y)*o;break;case R.add:e.y+=a*o}}}class zs extends ze{constructor(t,r,s){super(t,r,`${z.scaleX}|${s}`,`${z.scaleY}|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,r,s,i,o,m,d){const e=t.bones[this.boneIndex];if(!e.active)return;const n=this.frames;if(s<n[0]){switch(m){case R.setup:e.scaleX=e.data.scaleX,e.scaleY=e.data.scaleY;return;case R.first:e.scaleX+=(e.data.scaleX-e.scaleX)*o,e.scaleY+=(e.data.scaleY-e.scaleY)*o}return}let a,h;const l=rt.search(n,s,3),u=this.curves[l/3];switch(u){case 0:const f=n[l];a=n[l+1],h=n[l+2];const g=(s-f)/(n[l+3]-f);a+=(n[l+3+1]-a)*g,h+=(n[l+3+2]-h)*g;break;case 1:a=n[l+1],h=n[l+2];break;default:a=this.getBezierValue(s,l,1,u-2),h=this.getBezierValue(s,l,2,u+18-2)}if(a*=e.data.scaleX,h*=e.data.scaleY,o==1)m==R.add?(e.scaleX+=a-e.data.scaleX,e.scaleY+=h-e.data.scaleY):(e.scaleX=a,e.scaleY=h);else{let f=0,g=0;if(d==K.mixOut)switch(m){case R.setup:f=e.data.scaleX,g=e.data.scaleY,e.scaleX=f+(Math.abs(a)*F.signum(f)-f)*o,e.scaleY=g+(Math.abs(h)*F.signum(g)-g)*o;break;case R.first:case R.replace:f=e.scaleX,g=e.scaleY,e.scaleX=f+(Math.abs(a)*F.signum(f)-f)*o,e.scaleY=g+(Math.abs(h)*F.signum(g)-g)*o;break;case R.add:e.scaleX+=(a-e.data.scaleX)*o,e.scaleY+=(h-e.data.scaleY)*o}else switch(m){case R.setup:f=Math.abs(e.data.scaleX)*F.signum(a),g=Math.abs(e.data.scaleY)*F.signum(h),e.scaleX=f+(a-f)*o,e.scaleY=g+(h-g)*o;break;case R.first:case R.replace:f=Math.abs(e.scaleX)*F.signum(a),g=Math.abs(e.scaleY)*F.signum(h),e.scaleX=f+(a-f)*o,e.scaleY=g+(h-g)*o;break;case R.add:e.scaleX+=(a-e.data.scaleX)*o,e.scaleY+=(h-e.data.scaleY)*o}}}}class Gs extends Ht{constructor(t,r,s){super(t,r,`${z.scaleX}|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,r,s,i,o,m,d){const e=t.bones[this.boneIndex];if(!e.active)return;const n=this.frames;if(s<n[0]){switch(m){case R.setup:e.scaleX=e.data.scaleX;return;case R.first:e.scaleX+=(e.data.scaleX-e.scaleX)*o}return}const a=this.getCurveValue(s)*e.data.scaleX;if(o==1)m==R.add?e.scaleX+=a-e.data.scaleX:e.scaleX=a;else{let h=0;if(d==K.mixOut)switch(m){case R.setup:h=e.data.scaleX,e.scaleX=h+(Math.abs(a)*F.signum(h)-h)*o;break;case R.first:case R.replace:h=e.scaleX,e.scaleX=h+(Math.abs(a)*F.signum(h)-h)*o;break;case R.add:e.scaleX+=(a-e.data.scaleX)*o}else switch(m){case R.setup:h=Math.abs(e.data.scaleX)*F.signum(a),e.scaleX=h+(a-h)*o;break;case R.first:case R.replace:h=Math.abs(e.scaleX)*F.signum(a),e.scaleX=h+(a-h)*o;break;case R.add:e.scaleX+=(a-e.data.scaleX)*o}}}}class Hs extends Ht{constructor(t,r,s){super(t,r,`${z.scaleY}|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,r,s,i,o,m,d){const e=t.bones[this.boneIndex];if(!e.active)return;const n=this.frames;if(s<n[0]){switch(m){case R.setup:e.scaleY=e.data.scaleY;return;case R.first:e.scaleY+=(e.data.scaleY-e.scaleY)*o}return}const a=this.getCurveValue(s)*e.data.scaleY;if(o==1)m==R.add?e.scaleY+=a-e.data.scaleY:e.scaleY=a;else{let h=0;if(d==K.mixOut)switch(m){case R.setup:h=e.data.scaleY,e.scaleY=h+(Math.abs(a)*F.signum(h)-h)*o;break;case R.first:case R.replace:h=e.scaleY,e.scaleY=h+(Math.abs(a)*F.signum(h)-h)*o;break;case R.add:e.scaleY+=(a-e.data.scaleY)*o}else switch(m){case R.setup:h=Math.abs(e.data.scaleY)*F.signum(a),e.scaleY=h+(a-h)*o;break;case R.first:case R.replace:h=Math.abs(e.scaleY)*F.signum(a),e.scaleY=h+(a-h)*o;break;case R.add:e.scaleY+=(a-e.data.scaleY)*o}}}}class qs extends ze{constructor(t,r,s){super(t,r,`${z.shearX}|${s}`,`${z.shearY}|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,r,s,i,o,m,d){const e=t.bones[this.boneIndex];if(!e.active)return;const n=this.frames;if(s<n[0]){switch(m){case R.setup:e.shearX=e.data.shearX,e.shearY=e.data.shearY;return;case R.first:e.shearX+=(e.data.shearX-e.shearX)*o,e.shearY+=(e.data.shearY-e.shearY)*o}return}let a=0,h=0;const l=rt.search(n,s,3),u=this.curves[l/3];switch(u){case 0:const f=n[l];a=n[l+1],h=n[l+2];const g=(s-f)/(n[l+3]-f);a+=(n[l+3+1]-a)*g,h+=(n[l+3+2]-h)*g;break;case 1:a=n[l+1],h=n[l+2];break;default:a=this.getBezierValue(s,l,1,u-2),h=this.getBezierValue(s,l,2,u+18-2)}switch(m){case R.setup:e.shearX=e.data.shearX+a*o,e.shearY=e.data.shearY+h*o;break;case R.first:case R.replace:e.shearX+=(e.data.shearX+a-e.shearX)*o,e.shearY+=(e.data.shearY+h-e.shearY)*o;break;case R.add:e.shearX+=a*o,e.shearY+=h*o}}}class Ws extends Ht{constructor(t,r,s){super(t,r,`${z.shearX}|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,r,s,i,o,m,d){const e=t.bones[this.boneIndex];if(!e.active)return;const n=this.frames;if(s<n[0]){switch(m){case R.setup:e.shearX=e.data.shearX;return;case R.first:e.shearX+=(e.data.shearX-e.shearX)*o}return}const a=this.getCurveValue(s);switch(m){case R.setup:e.shearX=e.data.shearX+a*o;break;case R.first:case R.replace:e.shearX+=(e.data.shearX+a-e.shearX)*o;break;case R.add:e.shearX+=a*o}}}class Zs extends Ht{constructor(t,r,s){super(t,r,`${z.shearY}|${s}`),this.boneIndex=0,this.boneIndex=s}apply(t,r,s,i,o,m,d){const e=t.bones[this.boneIndex];if(!e.active)return;const n=this.frames;if(s<n[0]){switch(m){case R.setup:e.shearY=e.data.shearY;return;case R.first:e.shearY+=(e.data.shearY-e.shearY)*o}return}const a=this.getCurveValue(s);switch(m){case R.setup:e.shearY=e.data.shearY+a*o;break;case R.first:case R.replace:e.shearY+=(e.data.shearY+a-e.shearY)*o;break;case R.add:e.shearY+=a*o}}}class js extends Gt{constructor(t,r,s){super(t,r,[`${z.rgb}|${s}`,`${z.alpha}|${s}`]),this.slotIndex=0,this.slotIndex=s}getFrameEntries(){return 5}setFrame(t,r,s,i,o,m){t*=5,this.frames[t]=r,this.frames[t+1]=s,this.frames[t+2]=i,this.frames[t+3]=o,this.frames[t+4]=m}apply(t,r,s,i,o,m,d){const e=t.slots[this.slotIndex];if(!e.bone.active)return;const n=this.frames,a=e.color;if(s<n[0]){const E=e.data.color;switch(m){case R.setup:a.setFromColor(E);return;case R.first:a.add((E.r-a.r)*o,(E.g-a.g)*o,(E.b-a.b)*o,(E.a-a.a)*o)}return}let h=0,l=0,u=0,f=0;const g=rt.search(n,s,5),w=this.curves[g/5];switch(w){case 0:const E=n[g];h=n[g+1],l=n[g+2],u=n[g+3],f=n[g+4];const x=(s-E)/(n[g+5]-E);h+=(n[g+5+1]-h)*x,l+=(n[g+5+2]-l)*x,u+=(n[g+5+3]-u)*x,f+=(n[g+5+4]-f)*x;break;case 1:h=n[g+1],l=n[g+2],u=n[g+3],f=n[g+4];break;default:h=this.getBezierValue(s,g,1,w-2),l=this.getBezierValue(s,g,2,w+18-2),u=this.getBezierValue(s,g,3,w+18*2-2),f=this.getBezierValue(s,g,4,w+18*3-2)}o==1?a.set(h,l,u,f):(m==R.setup&&a.setFromColor(e.data.color),a.add((h-a.r)*o,(l-a.g)*o,(u-a.b)*o,(f-a.a)*o))}}class Js extends Gt{constructor(t,r,s){super(t,r,[`${z.rgb}|${s}`]),this.slotIndex=0,this.slotIndex=s}getFrameEntries(){return 4}setFrame(t,r,s,i,o){t<<=2,this.frames[t]=r,this.frames[t+1]=s,this.frames[t+2]=i,this.frames[t+3]=o}apply(t,r,s,i,o,m,d){const e=t.slots[this.slotIndex];if(!e.bone.active)return;const n=this.frames,a=e.color;if(s<n[0]){const w=e.data.color;switch(m){case R.setup:a.r=w.r,a.g=w.g,a.b=w.b;return;case R.first:a.r+=(w.r-a.r)*o,a.g+=(w.g-a.g)*o,a.b+=(w.b-a.b)*o}return}let h=0,l=0,u=0;const f=rt.search(n,s,4),g=this.curves[f>>2];switch(g){case 0:const w=n[f];h=n[f+1],l=n[f+2],u=n[f+3];const E=(s-w)/(n[f+4]-w);h+=(n[f+4+1]-h)*E,l+=(n[f+4+2]-l)*E,u+=(n[f+4+3]-u)*E;break;case 1:h=n[f+1],l=n[f+2],u=n[f+3];break;default:h=this.getBezierValue(s,f,1,g-2),l=this.getBezierValue(s,f,2,g+18-2),u=this.getBezierValue(s,f,3,g+18*2-2)}if(o==1)a.r=h,a.g=l,a.b=u;else{if(m==R.setup){const w=e.data.color;a.r=w.r,a.g=w.g,a.b=w.b}a.r+=(h-a.r)*o,a.g+=(l-a.g)*o,a.b+=(u-a.b)*o}}}class Ks extends Ht{constructor(t,r,s){super(t,r,`${z.alpha}|${s}`),this.slotIndex=0,this.slotIndex=s}apply(t,r,s,i,o,m,d){const e=t.slots[this.slotIndex];if(!e.bone.active)return;const n=e.color;if(s<this.frames[0]){const h=e.data.color;switch(m){case R.setup:n.a=h.a;return;case R.first:n.a+=(h.a-n.a)*o}return}const a=this.getCurveValue(s);o==1?n.a=a:(m==R.setup&&(n.a=e.data.color.a),n.a+=(a-n.a)*o)}}class Qs extends Gt{constructor(t,r,s){super(t,r,[`${z.rgb}|${s}`,`${z.alpha}|${s}`,`${z.rgb2}|${s}`]),this.slotIndex=0,this.slotIndex=s}getFrameEntries(){return 8}setFrame(t,r,s,i,o,m,d,e,n){t<<=3,this.frames[t]=r,this.frames[t+1]=s,this.frames[t+2]=i,this.frames[t+3]=o,this.frames[t+4]=m,this.frames[t+5]=d,this.frames[t+6]=e,this.frames[t+7]=n}apply(t,r,s,i,o,m,d){const e=t.slots[this.slotIndex];if(!e.bone.active)return;const n=this.frames,a=e.color,h=e.darkColor;if(s<n[0]){const y=e.data.color,S=e.data.darkColor;switch(m){case R.setup:a.setFromColor(y),h.r=S.r,h.g=S.g,h.b=S.b;return;case R.first:a.add((y.r-a.r)*o,(y.g-a.g)*o,(y.b-a.b)*o,(y.a-a.a)*o),h.r+=(S.r-h.r)*o,h.g+=(S.g-h.g)*o,h.b+=(S.b-h.b)*o}return}let l=0,u=0,f=0,g=0,w=0,E=0,x=0;const p=rt.search(n,s,8),b=this.curves[p>>3];switch(b){case 0:const y=n[p];l=n[p+1],u=n[p+2],f=n[p+3],g=n[p+4],w=n[p+5],E=n[p+6],x=n[p+7];const S=(s-y)/(n[p+8]-y);l+=(n[p+8+1]-l)*S,u+=(n[p+8+2]-u)*S,f+=(n[p+8+3]-f)*S,g+=(n[p+8+4]-g)*S,w+=(n[p+8+5]-w)*S,E+=(n[p+8+6]-E)*S,x+=(n[p+8+7]-x)*S;break;case 1:l=n[p+1],u=n[p+2],f=n[p+3],g=n[p+4],w=n[p+5],E=n[p+6],x=n[p+7];break;default:l=this.getBezierValue(s,p,1,b-2),u=this.getBezierValue(s,p,2,b+18-2),f=this.getBezierValue(s,p,3,b+18*2-2),g=this.getBezierValue(s,p,4,b+18*3-2),w=this.getBezierValue(s,p,5,b+18*4-2),E=this.getBezierValue(s,p,6,b+18*5-2),x=this.getBezierValue(s,p,7,b+18*6-2)}if(o==1)a.set(l,u,f,g),h.r=w,h.g=E,h.b=x;else{if(m==R.setup){a.setFromColor(e.data.color);const y=e.data.darkColor;h.r=y.r,h.g=y.g,h.b=y.b}a.add((l-a.r)*o,(u-a.g)*o,(f-a.b)*o,(g-a.a)*o),h.r+=(w-h.r)*o,h.g+=(E-h.g)*o,h.b+=(x-h.b)*o}}}class tn extends Gt{constructor(t,r,s){super(t,r,[`${z.rgb}|${s}`,`${z.rgb2}|${s}`]),this.slotIndex=0,this.slotIndex=s}getFrameEntries(){return 7}setFrame(t,r,s,i,o,m,d,e){t*=7,this.frames[t]=r,this.frames[t+1]=s,this.frames[t+2]=i,this.frames[t+3]=o,this.frames[t+4]=m,this.frames[t+5]=d,this.frames[t+6]=e}apply(t,r,s,i,o,m,d){const e=t.slots[this.slotIndex];if(!e.bone.active)return;const n=this.frames,a=e.color,h=e.darkColor;if(s<n[0]){const b=e.data.color,y=e.data.darkColor;switch(m){case R.setup:a.r=b.r,a.g=b.g,a.b=b.b,h.r=y.r,h.g=y.g,h.b=y.b;return;case R.first:a.r+=(b.r-a.r)*o,a.g+=(b.g-a.g)*o,a.b+=(b.b-a.b)*o,h.r+=(y.r-h.r)*o,h.g+=(y.g-h.g)*o,h.b+=(y.b-h.b)*o}return}let l=0,u=0,f=0,g=0,w=0,E=0;const x=rt.search(n,s,7),p=this.curves[x/7];switch(p){case 0:const b=n[x];l=n[x+1],u=n[x+2],f=n[x+3],g=n[x+4],w=n[x+5],E=n[x+6];const y=(s-b)/(n[x+7]-b);l+=(n[x+7+1]-l)*y,u+=(n[x+7+2]-u)*y,f+=(n[x+7+3]-f)*y,g+=(n[x+7+4]-g)*y,w+=(n[x+7+5]-w)*y,E+=(n[x+7+6]-E)*y;break;case 1:l=n[x+1],u=n[x+2],f=n[x+3],g=n[x+4],w=n[x+5],E=n[x+6];break;default:l=this.getBezierValue(s,x,1,p-2),u=this.getBezierValue(s,x,2,p+18-2),f=this.getBezierValue(s,x,3,p+18*2-2),g=this.getBezierValue(s,x,4,p+18*3-2),w=this.getBezierValue(s,x,5,p+18*4-2),E=this.getBezierValue(s,x,6,p+18*5-2)}if(o==1)a.r=l,a.g=u,a.b=f,h.r=g,h.g=w,h.b=E;else{if(m==R.setup){const b=e.data.color,y=e.data.darkColor;a.r=b.r,a.g=b.g,a.b=b.b,h.r=y.r,h.g=y.g,h.b=y.b}a.r+=(l-a.r)*o,a.g+=(u-a.g)*o,a.b+=(f-a.b)*o,h.r+=(g-h.r)*o,h.g+=(w-h.g)*o,h.b+=(E-h.b)*o}}}class en extends rt{constructor(t,r){super(t,[`${z.attachment}|${r}`]),this.slotIndex=0,this.slotIndex=r,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,r,s){this.frames[t]=r,this.attachmentNames[t]=s}apply(t,r,s,i,o,m,d){const e=t.slots[this.slotIndex];if(e.bone.active){if(d==K.mixOut){m==R.setup&&this.setAttachment(t,e,e.data.attachmentName);return}if(s<this.frames[0]){(m==R.setup||m==R.first)&&this.setAttachment(t,e,e.data.attachmentName);return}this.setAttachment(t,e,this.attachmentNames[rt.search1(this.frames,s)])}}setAttachment(t,r,s){r.setAttachment(s?t.getAttachment(this.slotIndex,s):null)}}class sn extends Gt{constructor(t,r,s,i){super(t,r,[`${z.deform}|${s}|${i.id}`]),this.slotIndex=0,this.slotIndex=s,this.attachment=i,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,r,s){this.frames[t]=r,this.vertices[t]=s}setBezier(t,r,s,i,o,m,d,e,n,a,h){const l=this.curves;let u=this.getFrameCount()+t*18;s==0&&(l[r]=2+u);const f=(i-m*2+e)*.03,g=n*.03-d*.06,w=((m-e)*3-i+a)*.006,E=(d-n+.33333333)*.018;let x=f*2+w,p=g*2+E,b=(m-i)*.3+f+w*.16666667,y=d*.3+g+E*.16666667,S=i+b,I=y;for(let v=u+18;u<v;u+=2)l[u]=S,l[u+1]=I,b+=x,y+=p,x+=w,p+=E,S+=b,I+=y}getCurvePercent(t,r){const s=this.curves;let i=s[r];switch(i){case 0:const e=this.frames[r];return(t-e)/(this.frames[r+this.getFrameEntries()]-e);case 1:return 0}if(i-=2,s[i]>t){const e=this.frames[r];return s[i+1]*(t-e)/(s[i]-e)}const o=i+18;for(i+=2;i<o;i+=2)if(s[i]>=t){const e=s[i-2],n=s[i-1];return n+(t-e)/(s[i]-e)*(s[i+1]-n)}const m=s[o-2],d=s[o-1];return d+(1-d)*(t-m)/(this.frames[r+this.getFrameEntries()]-m)}apply(t,r,s,i,o,m,d){const e=t.slots[this.slotIndex];if(!e.bone.active)return;const n=e.getAttachment();if(!n||!(n instanceof ie)||n.timelineAttachment!=this.attachment)return;const a=e.deform;a.length==0&&(m=R.setup);const h=this.vertices,l=h[0].length,u=this.frames;if(s<u[0]){switch(m){case R.setup:a.length=0;return;case R.first:if(o==1){a.length=0;return}a.length=l;const x=n;if(x.bones){o=1-o;for(let p=0;p<l;p++)a[p]*=o}else{const p=x.vertices;for(let b=0;b<l;b++)a[b]+=(p[b]-a[b])*o}}return}if(a.length=l,s>=u[u.length-1]){const x=h[u.length-1];if(o==1)if(m==R.add){const p=n;if(p.bones)for(let b=0;b<l;b++)a[b]+=x[b];else{const b=p.vertices;for(let y=0;y<l;y++)a[y]+=x[y]-b[y]}}else C.arrayCopy(x,0,a,0,l);else switch(m){case R.setup:{const b=n;if(b.bones)for(let y=0;y<l;y++)a[y]=x[y]*o;else{const y=b.vertices;for(let S=0;S<l;S++){const I=y[S];a[S]=I+(x[S]-I)*o}}break}case R.first:case R.replace:for(let b=0;b<l;b++)a[b]+=(x[b]-a[b])*o;break;case R.add:const p=n;if(p.bones)for(let b=0;b<l;b++)a[b]+=x[b]*o;else{const b=p.vertices;for(let y=0;y<l;y++)a[y]+=(x[y]-b[y])*o}}return}const f=rt.search1(u,s),g=this.getCurvePercent(s,f),w=h[f],E=h[f+1];if(o==1)if(m==R.add){const x=n;if(x.bones)for(let p=0;p<l;p++){const b=w[p];a[p]+=b+(E[p]-b)*g}else{const p=x.vertices;for(let b=0;b<l;b++){const y=w[b];a[b]+=y+(E[b]-y)*g-p[b]}}}else for(let x=0;x<l;x++){const p=w[x];a[x]=p+(E[x]-p)*g}else switch(m){case R.setup:{const p=n;if(p.bones)for(let b=0;b<l;b++){const y=w[b];a[b]=(y+(E[b]-y)*g)*o}else{const b=p.vertices;for(let y=0;y<l;y++){const S=w[y],I=b[y];a[y]=I+(S+(E[y]-S)*g-I)*o}}break}case R.first:case R.replace:for(let p=0;p<l;p++){const b=w[p];a[p]+=(b+(E[p]-b)*g-a[p])*o}break;case R.add:const x=n;if(x.bones)for(let p=0;p<l;p++){const b=w[p];a[p]+=(b+(E[p]-b)*g)*o}else{const p=x.vertices;for(let b=0;b<l;b++){const y=w[b];a[b]+=(y+(E[b]-y)*g-p[b])*o}}}}}const nn=class extends rt{constructor(c){super(c,nn.propertyIds),this.events=new Array(c)}getFrameCount(){return this.frames.length}setFrame(c,t){this.frames[c]=t.time,this.events[c]=t}apply(c,t,r,s,i,o,m){if(!s)return;const d=this.frames,e=this.frames.length;if(t>r)this.apply(c,t,Number.MAX_VALUE,s,i,o,m),t=-1;else if(t>=d[e-1])return;if(r<d[0])return;let n=0;if(t<d[0])n=0;else{n=rt.search1(d,t)+1;const a=d[n];for(;n>0&&d[n-1]==a;)n--}for(;n<e&&r>=d[n];n++)s.push(this.events[n])}};let Ge=nn;Ge.propertyIds=[`${z.event}`];const rn=class extends rt{constructor(c){super(c,rn.propertyIds),this.drawOrders=new Array(c)}getFrameCount(){return this.frames.length}setFrame(c,t,r){this.frames[c]=t,this.drawOrders[c]=r}apply(c,t,r,s,i,o,m){if(m==K.mixOut){o==R.setup&&C.arrayCopy(c.slots,0,c.drawOrder,0,c.slots.length);return}if(r<this.frames[0]){(o==R.setup||o==R.first)&&C.arrayCopy(c.slots,0,c.drawOrder,0,c.slots.length);return}const d=rt.search1(this.frames,r),e=this.drawOrders[d];if(!e)C.arrayCopy(c.slots,0,c.drawOrder,0,c.slots.length);else{const n=c.drawOrder,a=c.slots;for(let h=0,l=e.length;h<l;h++)n[h]=a[e[h]]}}};let He=rn;He.propertyIds=[`${z.drawOrder}`];class on extends Gt{constructor(t,r,s){super(t,r,[`${z.ikConstraint}|${s}`]),this.ikConstraintIndex=0,this.ikConstraintIndex=s}getFrameEntries(){return 6}setFrame(t,r,s,i,o,m,d){t*=6,this.frames[t]=r,this.frames[t+1]=s,this.frames[t+2]=i,this.frames[t+3]=o,this.frames[t+4]=m?1:0,this.frames[t+5]=d?1:0}apply(t,r,s,i,o,m,d){const e=t.ikConstraints[this.ikConstraintIndex];if(!e.active)return;const n=this.frames;if(s<n[0]){switch(m){case R.setup:e.mix=e.data.mix,e.softness=e.data.softness,e.bendDirection=e.data.bendDirection,e.compress=e.data.compress,e.stretch=e.data.stretch;return;case R.first:e.mix+=(e.data.mix-e.mix)*o,e.softness+=(e.data.softness-e.softness)*o,e.bendDirection=e.data.bendDirection,e.compress=e.data.compress,e.stretch=e.data.stretch}return}let a=0,h=0;const l=rt.search(n,s,6),u=this.curves[l/6];switch(u){case 0:const f=n[l];a=n[l+1],h=n[l+2];const g=(s-f)/(n[l+6]-f);a+=(n[l+6+1]-a)*g,h+=(n[l+6+2]-h)*g;break;case 1:a=n[l+1],h=n[l+2];break;default:a=this.getBezierValue(s,l,1,u-2),h=this.getBezierValue(s,l,2,u+18-2)}m==R.setup?(e.mix=e.data.mix+(a-e.data.mix)*o,e.softness=e.data.softness+(h-e.data.softness)*o,d==K.mixOut?(e.bendDirection=e.data.bendDirection,e.compress=e.data.compress,e.stretch=e.data.stretch):(e.bendDirection=n[l+3],e.compress=n[l+4]!=0,e.stretch=n[l+5]!=0)):(e.mix+=(a-e.mix)*o,e.softness+=(h-e.softness)*o,d==K.mixIn&&(e.bendDirection=n[l+3],e.compress=n[l+4]!=0,e.stretch=n[l+5]!=0))}}class an extends Gt{constructor(t,r,s){super(t,r,[`${z.transformConstraint}|${s}`]),this.transformConstraintIndex=0,this.transformConstraintIndex=s}getFrameEntries(){return 7}setFrame(t,r,s,i,o,m,d,e){const n=this.frames;t*=7,n[t]=r,n[t+1]=s,n[t+2]=i,n[t+3]=o,n[t+4]=m,n[t+5]=d,n[t+6]=e}apply(t,r,s,i,o,m,d){const e=t.transformConstraints[this.transformConstraintIndex];if(!e.active)return;const n=this.frames;if(s<n[0]){const x=e.data;switch(m){case R.setup:e.mixRotate=x.mixRotate,e.mixX=x.mixX,e.mixY=x.mixY,e.mixScaleX=x.mixScaleX,e.mixScaleY=x.mixScaleY,e.mixShearY=x.mixShearY;return;case R.first:e.mixRotate+=(x.mixRotate-e.mixRotate)*o,e.mixX+=(x.mixX-e.mixX)*o,e.mixY+=(x.mixY-e.mixY)*o,e.mixScaleX+=(x.mixScaleX-e.mixScaleX)*o,e.mixScaleY+=(x.mixScaleY-e.mixScaleY)*o,e.mixShearY+=(x.mixShearY-e.mixShearY)*o}return}let a,h,l,u,f,g;const w=rt.search(n,s,7),E=this.curves[w/7];switch(E){case 0:const x=n[w];a=n[w+1],h=n[w+2],l=n[w+3],u=n[w+4],f=n[w+5],g=n[w+6];const p=(s-x)/(n[w+7]-x);a+=(n[w+7+1]-a)*p,h+=(n[w+7+2]-h)*p,l+=(n[w+7+3]-l)*p,u+=(n[w+7+4]-u)*p,f+=(n[w+7+5]-f)*p,g+=(n[w+7+6]-g)*p;break;case 1:a=n[w+1],h=n[w+2],l=n[w+3],u=n[w+4],f=n[w+5],g=n[w+6];break;default:a=this.getBezierValue(s,w,1,E-2),h=this.getBezierValue(s,w,2,E+18-2),l=this.getBezierValue(s,w,3,E+18*2-2),u=this.getBezierValue(s,w,4,E+18*3-2),f=this.getBezierValue(s,w,5,E+18*4-2),g=this.getBezierValue(s,w,6,E+18*5-2)}if(m==R.setup){const x=e.data;e.mixRotate=x.mixRotate+(a-x.mixRotate)*o,e.mixX=x.mixX+(h-x.mixX)*o,e.mixY=x.mixY+(l-x.mixY)*o,e.mixScaleX=x.mixScaleX+(u-x.mixScaleX)*o,e.mixScaleY=x.mixScaleY+(f-x.mixScaleY)*o,e.mixShearY=x.mixShearY+(g-x.mixShearY)*o}else e.mixRotate+=(a-e.mixRotate)*o,e.mixX+=(h-e.mixX)*o,e.mixY+=(l-e.mixY)*o,e.mixScaleX+=(u-e.mixScaleX)*o,e.mixScaleY+=(f-e.mixScaleY)*o,e.mixShearY+=(g-e.mixShearY)*o}}class ln extends Ht{constructor(t,r,s){super(t,r,`${z.pathConstraintPosition}|${s}`),this.pathConstraintIndex=0,this.pathConstraintIndex=s}apply(t,r,s,i,o,m,d){const e=t.pathConstraints[this.pathConstraintIndex];if(!e.active)return;const n=this.frames;if(s<n[0]){switch(m){case R.setup:e.position=e.data.position;return;case R.first:e.position+=(e.data.position-e.position)*o}return}const a=this.getCurveValue(s);m==R.setup?e.position=e.data.position+(a-e.data.position)*o:e.position+=(a-e.position)*o}}class cn extends Ht{constructor(t,r,s){super(t,r,`${z.pathConstraintSpacing}|${s}`),this.pathConstraintIndex=0,this.pathConstraintIndex=s}apply(t,r,s,i,o,m,d){const e=t.pathConstraints[this.pathConstraintIndex];if(!e.active)return;const n=this.frames;if(s<n[0]){switch(m){case R.setup:e.spacing=e.data.spacing;return;case R.first:e.spacing+=(e.data.spacing-e.spacing)*o}return}const a=this.getCurveValue(s);m==R.setup?e.spacing=e.data.spacing+(a-e.data.spacing)*o:e.spacing+=(a-e.spacing)*o}}class hn extends Gt{constructor(t,r,s){super(t,r,[`${z.pathConstraintMix}|${s}`]),this.pathConstraintIndex=0,this.pathConstraintIndex=s}getFrameEntries(){return 4}setFrame(t,r,s,i,o){const m=this.frames;t<<=2,m[t]=r,m[t+1]=s,m[t+2]=i,m[t+3]=o}apply(t,r,s,i,o,m,d){const e=t.pathConstraints[this.pathConstraintIndex];if(!e.active)return;const n=this.frames;if(s<n[0]){switch(m){case R.setup:e.mixRotate=e.data.mixRotate,e.mixX=e.data.mixX,e.mixY=e.data.mixY;return;case R.first:e.mixRotate+=(e.data.mixRotate-e.mixRotate)*o,e.mixX+=(e.data.mixX-e.mixX)*o,e.mixY+=(e.data.mixY-e.mixY)*o}return}let a,h,l;const u=rt.search(n,s,4),f=this.curves[u>>2];switch(f){case 0:const g=n[u];a=n[u+1],h=n[u+2],l=n[u+3];const w=(s-g)/(n[u+4]-g);a+=(n[u+4+1]-a)*w,h+=(n[u+4+2]-h)*w,l+=(n[u+4+3]-l)*w;break;case 1:a=n[u+1],h=n[u+2],l=n[u+3];break;default:a=this.getBezierValue(s,u,1,f-2),h=this.getBezierValue(s,u,2,f+18-2),l=this.getBezierValue(s,u,3,f+18*2-2)}if(m==R.setup){const g=e.data;e.mixRotate=g.mixRotate+(a-g.mixRotate)*o,e.mixX=g.mixX+(h-g.mixX)*o,e.mixY=g.mixY+(l-g.mixY)*o}else e.mixRotate+=(a-e.mixRotate)*o,e.mixX+=(h-e.mixX)*o,e.mixY+=(l-e.mixY)*o}}const ne=class extends rt{constructor(c,t,r){super(c,[`${z.sequence}|${t}|${r.sequence.id}`]),this.slotIndex=t,this.attachment=r}getFrameEntries(){return ne.ENTRIES}getSlotIndex(){return this.slotIndex}getAttachment(){return this.attachment}setFrame(c,t,r,s,i){const o=this.frames;c*=ne.ENTRIES,o[c]=t,o[c+ne.MODE]=r|s<<4,o[c+ne.DELAY]=i}apply(c,t,r,s,i,o,m){const d=c.slots[this.slotIndex];if(!d.bone.active)return;const e=d.attachment,n=this.attachment;if(e!=n&&(!(e instanceof ie)||e.timelineAttachment!=n))return;const a=this.frames;if(r<a[0]){(o==R.setup||o==R.first)&&(d.sequenceIndex=-1);return}const h=rt.search(a,r,ne.ENTRIES),l=a[h],u=a[h+ne.MODE],f=a[h+ne.DELAY];if(!this.attachment.sequence)return;let g=u>>4;const w=this.attachment.sequence.regions.length,E=Os[u&15];if(E!=Wt.hold)switch(g+=(r-l)/f+1e-5|0,E){case Wt.once:g=Math.min(w-1,g);break;case Wt.loop:g%=w;break;case Wt.pingpong:{const x=(w<<1)-2;g=x==0?0:g%x,g>=w&&(g=x-g);break}case Wt.onceReverse:g=Math.max(w-1-g,0);break;case Wt.loopReverse:g=w-1-g%w;break;case Wt.pingpongReverse:{const x=(w<<1)-2;g=x==0?0:(g+w-1)%x,g>=w&&(g=x-g)}}d.sequenceIndex=g}};let pe=ne;pe.ENTRIES=3;pe.MODE=1;pe.DELAY=2;new Ue("<empty>",[],0);class dn{constructor(t){this.atlas=t}loadSequence(t,r,s){const i=s.regions;for(let o=0,m=i.length;o<m;o++){const d=s.getPath(r,o),e=this.atlas.findRegion(d);if(e==null)throw new Error(`Region not found in atlas: ${d} (sequence: ${t})`);i[o]=e,i[o].renderObject=i[o]}}newRegionAttachment(t,r,s,i){const o=new U(r,s);if(i!=null)this.loadSequence(r,s,i);else{const m=this.atlas.findRegion(s);if(!m)throw new Error(`Region not found in atlas: ${s} (region attachment: ${r})`);m.renderObject=m,o.region=m}return o}newMeshAttachment(t,r,s,i){const o=new be(r,s);if(i!=null)this.loadSequence(r,s,i);else{const m=this.atlas.findRegion(s);if(!m)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${r})`);m.renderObject=m,o.region=m}return o}newBoundingBoxAttachment(t,r){return new Le(r)}newPathAttachment(t,r){return new _e(r)}newPointAttachment(t,r){return new $e(r)}newClippingAttachment(t,r){return new Oe(r)}}class un{constructor(t,r,s){if(this.index=0,this.parent=null,this.length=0,this.x=0,this.y=0,this.rotation=0,this.scaleX=1,this.scaleY=1,this.shearX=0,this.shearY=0,this.transformMode=st.Normal,this.skinRequired=!1,this.color=new T,t<0)throw new Error("index must be >= 0.");if(!r)throw new Error("name cannot be null.");this.index=t,this.name=r,this.parent=s}}class qe{constructor(t,r,s){this.name=t,this.order=r,this.skinRequired=s}}class fn{constructor(t,r){if(this.intValue=0,this.floatValue=0,this.stringValue=null,this.time=0,this.volume=0,this.balance=0,!r)throw new Error("data cannot be null.");this.time=t,this.data=r}}class mn{constructor(t){this.intValue=0,this.floatValue=0,this.stringValue=null,this.audioPath=null,this.volume=0,this.balance=0,this.name=t}}class gn extends qe{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.bendDirection=1,this.compress=!1,this.stretch=!1,this.uniform=!1,this.mix=1,this.softness=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class wn extends qe{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.positionMode=at.Fixed,this.spacingMode=$t.Fixed,this.rotateMode=vt.Chain,this.offsetRotation=0,this.position=0,this.spacing=0,this.mixRotate=0,this.mixX=0,this.mixY=0}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("SlotData not set.")}}var $t=(c=>(c[c.Length=0]="Length",c[c.Fixed=1]="Fixed",c[c.Percent=2]="Percent",c[c.Proportional=3]="Proportional",c))($t||{});class xn{constructor(){this.name=null,this.bones=new Array,this.slots=new Array,this.skins=new Array,this.defaultSkin=null,this.events=new Array,this.animations=new Array,this.ikConstraints=new Array,this.transformConstraints=new Array,this.pathConstraints=new Array,this.x=0,this.y=0,this.width=0,this.height=0,this.version=null,this.hash=null,this.fps=0,this.imagesPath=null,this.audioPath=null}findBone(t){if(!t)throw new Error("boneName cannot be null.");const r=this.bones;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const r=this.bones;for(let s=0,i=r.length;s<i;s++)if(r[s].name==t)return s;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const r=this.slots;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const r=this.slots;for(let s=0,i=r.length;s<i;s++)if(r[s].name==t)return s;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const r=this.skins;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const r=this.events;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const r=this.animations;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const r=this.ikConstraints;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const r=this.transformConstraints;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const r=this.pathConstraints;for(let s=0,i=r.length;s<i;s++){const o=r[s];if(o.name==t)return o}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const r=this.pathConstraints;for(let s=0,i=r.length;s<i;s++)if(r[s].name==t)return s;return-1}}class En{constructor(t,r,s){if(this.index=0,this.color=new T(1,1,1,1),this.darkColor=null,this.attachmentName=null,this.blendMode=et.NORMAL,t<0)throw new Error("index must be >= 0.");if(!r)throw new Error("name cannot be null.");if(!s)throw new Error("boneData cannot be null.");this.index=t,this.name=r,this.boneData=s}}class bn extends qe{constructor(t){super(t,0,!1),this.bones=new Array,this._target=null,this.mixRotate=0,this.mixX=0,this.mixY=0,this.mixScaleX=0,this.mixScaleY=0,this.mixShearY=0,this.offsetRotation=0,this.offsetX=0,this.offsetY=0,this.offsetScaleX=0,this.offsetScaleY=0,this.offsetShearY=0,this.relative=!1,this.local=!1}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}class ss{constructor(t,r,s){this.slotIndex=t,this.name=r,this.attachment=s}}class Ye{constructor(t){if(this.attachments=new Array,this.bones=Array(),this.constraints=new Array,!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,r,s){if(!s)throw new Error("attachment cannot be null.");const i=this.attachments;t>=i.length&&(i.length=t+1),i[t]||(i[t]={}),i[t][r]=s}addSkin(t){for(let s=0;s<t.bones.length;s++){const i=t.bones[s];let o=!1;for(let m=0;m<this.bones.length;m++)if(this.bones[m]==i){o=!0;break}o||this.bones.push(i)}for(let s=0;s<t.constraints.length;s++){const i=t.constraints[s];let o=!1;for(let m=0;m<this.constraints.length;m++)if(this.constraints[m]==i){o=!0;break}o||this.constraints.push(i)}const r=t.getAttachments();for(let s=0;s<r.length;s++){const i=r[s];this.setAttachment(i.slotIndex,i.name,i.attachment)}}copySkin(t){for(let s=0;s<t.bones.length;s++){const i=t.bones[s];let o=!1;for(let m=0;m<this.bones.length;m++)if(this.bones[m]==i){o=!0;break}o||this.bones.push(i)}for(let s=0;s<t.constraints.length;s++){const i=t.constraints[s];let o=!1;for(let m=0;m<this.constraints.length;m++)if(this.constraints[m]==i){o=!0;break}o||this.constraints.push(i)}const r=t.getAttachments();for(let s=0;s<r.length;s++){const i=r[s];i.attachment&&(i.attachment instanceof be?(i.attachment=i.attachment.newLinkedMesh(),this.setAttachment(i.slotIndex,i.name,i.attachment)):(i.attachment=i.attachment.copy(),this.setAttachment(i.slotIndex,i.name,i.attachment)))}}getAttachment(t,r){const s=this.attachments[t];return s?s[r]:null}removeAttachment(t,r){const s=this.attachments[t];s&&delete s[r]}getAttachments(){const t=new Array;for(let r=0;r<this.attachments.length;r++){const s=this.attachments[r];if(s)for(const i in s){const o=s[i];o&&t.push(new ss(r,i,o))}}return t}getAttachmentsForSlot(t,r){const s=this.attachments[t];if(s)for(const i in s){const o=s[i];o&&r.push(new ss(t,i,o))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,r){let s=0;for(let i=0;i<t.slots.length;i++){const o=t.slots[i],m=o.getAttachment();if(m&&s<r.attachments.length){const d=r.attachments[s];for(const e in d){const n=d[e];if(m==n){const a=this.getAttachment(s,e);a&&o.setAttachment(a);break}}}s++}}}class pn{constructor(t){this.ver40=!1,this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const r=this.scale,s=new xn;s.name="";const i=new Ce(t),o=i.readInt32(),m=i.readInt32();s.hash=m==0&&o==0?null:m.toString(16)+o.toString(16),s.version=i.readString();const d=s.version.substr(0,3);if(d!=="4.0"&&d!=="4.1"){const h=`Spine 4.1 loader cant load version ${s.version}. Please configure your pixi-spine bundle`;console.error(h)}this.ver40=d==="4.0",s.x=i.readFloat(),s.y=i.readFloat(),s.width=i.readFloat(),s.height=i.readFloat();const e=i.readBoolean();e&&(s.fps=i.readFloat(),s.imagesPath=i.readString(),s.audioPath=i.readString());let n=0;n=i.readInt(!0);for(let h=0;h<n;h++){const l=i.readString();if(!l)throw new Error("String in string table must not be null.");i.strings.push(l)}n=i.readInt(!0);for(let h=0;h<n;h++){const l=i.readString();if(!l)throw new Error("Bone name must not be null.");const u=h==0?null:s.bones[i.readInt(!0)],f=new un(h,l,u);f.rotation=i.readFloat(),f.x=i.readFloat()*r,f.y=i.readFloat()*r,f.scaleX=i.readFloat(),f.scaleY=i.readFloat(),f.shearX=i.readFloat(),f.shearY=i.readFloat(),f.length=i.readFloat()*r,f.transformMode=i.readInt(!0),f.skinRequired=i.readBoolean(),e&&T.rgba8888ToColor(f.color,i.readInt32()),s.bones.push(f)}n=i.readInt(!0);for(let h=0;h<n;h++){const l=i.readString();if(!l)throw new Error("Slot name must not be null.");const u=s.bones[i.readInt(!0)],f=new En(h,l,u);T.rgba8888ToColor(f.color,i.readInt32());const g=i.readInt32();g!=-1&&T.rgb888ToColor(f.darkColor=new T,g),f.attachmentName=i.readStringRef(),f.blendMode=i.readInt(!0),s.slots.push(f)}n=i.readInt(!0);for(let h=0,l;h<n;h++){const u=i.readString();if(!u)throw new Error("IK constraint data name must not be null.");const f=new gn(u);f.order=i.readInt(!0),f.skinRequired=i.readBoolean(),l=i.readInt(!0);for(let g=0;g<l;g++)f.bones.push(s.bones[i.readInt(!0)]);f.target=s.bones[i.readInt(!0)],f.mix=i.readFloat(),f.softness=i.readFloat()*r,f.bendDirection=i.readByte(),f.compress=i.readBoolean(),f.stretch=i.readBoolean(),f.uniform=i.readBoolean(),s.ikConstraints.push(f)}n=i.readInt(!0);for(let h=0,l;h<n;h++){const u=i.readString();if(!u)throw new Error("Transform constraint data name must not be null.");const f=new bn(u);f.order=i.readInt(!0),f.skinRequired=i.readBoolean(),l=i.readInt(!0);for(let g=0;g<l;g++)f.bones.push(s.bones[i.readInt(!0)]);f.target=s.bones[i.readInt(!0)],f.local=i.readBoolean(),f.relative=i.readBoolean(),f.offsetRotation=i.readFloat(),f.offsetX=i.readFloat()*r,f.offsetY=i.readFloat()*r,f.offsetScaleX=i.readFloat(),f.offsetScaleY=i.readFloat(),f.offsetShearY=i.readFloat(),f.mixRotate=i.readFloat(),f.mixX=i.readFloat(),f.mixY=i.readFloat(),f.mixScaleX=i.readFloat(),f.mixScaleY=i.readFloat(),f.mixShearY=i.readFloat(),s.transformConstraints.push(f)}n=i.readInt(!0);for(let h=0,l;h<n;h++){const u=i.readString();if(!u)throw new Error("Path constraint data name must not be null.");const f=new wn(u);f.order=i.readInt(!0),f.skinRequired=i.readBoolean(),l=i.readInt(!0);for(let g=0;g<l;g++)f.bones.push(s.bones[i.readInt(!0)]);f.target=s.slots[i.readInt(!0)],f.positionMode=i.readInt(!0),f.spacingMode=i.readInt(!0),f.rotateMode=i.readInt(!0),f.offsetRotation=i.readFloat(),f.position=i.readFloat(),f.positionMode==at.Fixed&&(f.position*=r),f.spacing=i.readFloat(),(f.spacingMode==$t.Length||f.spacingMode==$t.Fixed)&&(f.spacing*=r),f.mixRotate=i.readFloat(),f.mixX=i.readFloat(),f.mixY=i.readFloat(),s.pathConstraints.push(f)}const a=this.readSkin(i,s,!0,e);a&&(s.defaultSkin=a,s.skins.push(a));{let h=s.skins.length;for(C.setArraySize(s.skins,n=h+i.readInt(!0));h<n;h++){const l=this.readSkin(i,s,!1,e);if(!l)throw new Error("readSkin() should not have returned null.");s.skins[h]=l}}n=this.linkedMeshes.length;for(let h=0;h<n;h++){const l=this.linkedMeshes[h],u=l.skin?s.findSkin(l.skin):s.defaultSkin;if(!u)throw new Error("Not skin found for linked mesh.");if(!l.parent)throw new Error("Linked mesh parent must not be null");const f=u.getAttachment(l.slotIndex,l.parent);if(!f)throw new Error(`Parent mesh not found: ${l.parent}`);l.mesh.timelineAttachment=l.inheritTimeline?f:l.mesh,l.mesh.setParentMesh(f)}this.linkedMeshes.length=0,n=i.readInt(!0);for(let h=0;h<n;h++){const l=i.readStringRef();if(!l)throw new Error;const u=new mn(l);u.intValue=i.readInt(!1),u.floatValue=i.readFloat(),u.stringValue=i.readString(),u.audioPath=i.readString(),u.audioPath&&(u.volume=i.readFloat(),u.balance=i.readFloat()),s.events.push(u)}n=i.readInt(!0);for(let h=0;h<n;h++){const l=i.readString();if(!l)throw new Error("Animatio name must not be null.");s.animations.push(this.readAnimation(i,l,s))}return s}readSkin(t,r,s,i){let o=null,m=0;if(s){if(m=t.readInt(!0),m==0)return null;o=new Ye("default")}else{const d=t.readStringRef();if(!d)throw new Error("Skin name must not be null.");o=new Ye(d),o.bones.length=t.readInt(!0);for(let e=0,n=o.bones.length;e<n;e++)o.bones[e]=r.bones[t.readInt(!0)];for(let e=0,n=t.readInt(!0);e<n;e++)o.constraints.push(r.ikConstraints[t.readInt(!0)]);for(let e=0,n=t.readInt(!0);e<n;e++)o.constraints.push(r.transformConstraints[t.readInt(!0)]);for(let e=0,n=t.readInt(!0);e<n;e++)o.constraints.push(r.pathConstraints[t.readInt(!0)]);m=t.readInt(!0)}for(let d=0;d<m;d++){const e=t.readInt(!0);for(let n=0,a=t.readInt(!0);n<a;n++){const h=t.readStringRef();if(!h)throw new Error("Attachment name must not be null");const l=this.readAttachment(t,r,o,e,h,i);l&&o.setAttachment(e,h,l)}}return o}readAttachment(t,r,s,i,o,m){const d=this.scale;let e=t.readStringRef();switch(e||(e=o),t.readByte()){case B.Region:{let n=t.readStringRef();const a=t.readFloat(),h=t.readFloat(),l=t.readFloat(),u=t.readFloat(),f=t.readFloat(),g=t.readFloat(),w=t.readFloat(),E=t.readInt32(),x=this.readSequence(t);n||(n=e);const p=this.attachmentLoader.newRegionAttachment(s,e,n,x);return p?(p.path=n,p.x=h*d,p.y=l*d,p.scaleX=u,p.scaleY=f,p.rotation=a,p.width=g*d,p.height=w*d,T.rgba8888ToColor(p.color,E),p.sequence=x,x==null&&p.updateRegion(),p):null}case B.BoundingBox:{const n=t.readInt(!0),a=this.readVertices(t,n),h=m?t.readInt32():0,l=this.attachmentLoader.newBoundingBoxAttachment(s,e);return l?(l.worldVerticesLength=n<<1,l.vertices=a.vertices,l.bones=a.bones,m&&T.rgba8888ToColor(l.color,h),l):null}case B.Mesh:{let n=t.readStringRef();const a=t.readInt32(),h=t.readInt(!0),l=this.readFloatArray(t,h<<1,1),u=this.readShortArray(t),f=this.readVertices(t,h),g=t.readInt(!0),w=this.readSequence(t);let E=[],x=0,p=0;m&&(E=this.readShortArray(t),x=t.readFloat(),p=t.readFloat()),n||(n=e);const b=this.attachmentLoader.newMeshAttachment(s,e,n,w);return b?(b.path=n,T.rgba8888ToColor(b.color,a),b.bones=f.bones,b.vertices=f.vertices,b.worldVerticesLength=h<<1,b.triangles=u,b.regionUVs=new Float32Array(l),b.hullLength=g<<1,b.sequence=w,m&&(b.edges=E,b.width=x*d,b.height=p*d),b):null}case B.LinkedMesh:{let n=t.readStringRef();const a=t.readInt32(),h=t.readStringRef(),l=t.readStringRef(),u=t.readBoolean(),f=this.readSequence(t);let g=0,w=0;m&&(g=t.readFloat(),w=t.readFloat()),n||(n=e);const E=this.attachmentLoader.newMeshAttachment(s,e,n,f);return E?(E.path=n,T.rgba8888ToColor(E.color,a),E.sequence=f,m&&(E.width=g*d,E.height=w*d),this.linkedMeshes.push(new Sr(E,h,i,l,u)),E):null}case B.Path:{const n=t.readBoolean(),a=t.readBoolean(),h=t.readInt(!0),l=this.readVertices(t,h),u=C.newArray(h/3,0);for(let w=0,E=u.length;w<E;w++)u[w]=t.readFloat()*d;const f=m?t.readInt32():0,g=this.attachmentLoader.newPathAttachment(s,e);return g?(g.closed=n,g.constantSpeed=a,g.worldVerticesLength=h<<1,g.vertices=l.vertices,g.bones=l.bones,g.lengths=u,m&&T.rgba8888ToColor(g.color,f),g):null}case B.Point:{const n=t.readFloat(),a=t.readFloat(),h=t.readFloat(),l=m?t.readInt32():0,u=this.attachmentLoader.newPointAttachment(s,e);return u?(u.x=a*d,u.y=h*d,u.rotation=n,m&&T.rgba8888ToColor(u.color,l),u):null}case B.Clipping:{const n=t.readInt(!0),a=t.readInt(!0),h=this.readVertices(t,a),l=m?t.readInt32():0,u=this.attachmentLoader.newClippingAttachment(s,e);return u?(u.endSlot=r.slots[n],u.worldVerticesLength=a<<1,u.vertices=h.vertices,u.bones=h.bones,m&&T.rgba8888ToColor(u.color,l),u):null}}return null}readSequence(t){if(this.ver40||!t.readBoolean())return null;const r=new De(t.readInt(!0));return r.start=t.readInt(!0),r.digits=t.readInt(!0),r.setupIndex=t.readInt(!0),r}readDeformTimelineType(t){return this.ver40?ns:t.readByte()}readVertices(t,r){const s=this.scale,i=r<<1,o=new Rr;if(!t.readBoolean())return o.vertices=this.readFloatArray(t,i,s),o;const m=new Array,d=new Array;for(let e=0;e<r;e++){const n=t.readInt(!0);d.push(n);for(let a=0;a<n;a++)d.push(t.readInt(!0)),m.push(t.readFloat()*s),m.push(t.readFloat()*s),m.push(t.readFloat())}return o.vertices=C.toFloatArray(m),o.bones=d,o}readFloatArray(t,r,s){const i=new Array(r);if(s==1)for(let o=0;o<r;o++)i[o]=t.readFloat();else for(let o=0;o<r;o++)i[o]=t.readFloat()*s;return i}readShortArray(t){const r=t.readInt(!0),s=new Array(r);for(let i=0;i<r;i++)s[i]=t.readShort();return s}readAnimation(t,r,s){t.readInt(!0);const i=new Array,o=this.scale;for(let n=0,a=t.readInt(!0);n<a;n++){const h=t.readInt(!0);for(let l=0,u=t.readInt(!0);l<u;l++){const f=t.readByte(),g=t.readInt(!0),w=g-1;switch(f){case Nr:{const E=new en(g,h);for(let x=0;x<g;x++)E.setFrame(x,t.readFloat(),t.readStringRef());i.push(E);break}case Yr:{const E=t.readInt(!0),x=new js(g,E,h);let p=t.readFloat(),b=t.readUnsignedByte()/255,y=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,I=t.readUnsignedByte()/255;for(let v=0,M=0;x.setFrame(v,p,b,y,S,I),v!=w;v++){const P=t.readFloat(),V=t.readUnsignedByte()/255,k=t.readUnsignedByte()/255,N=t.readUnsignedByte()/255,H=t.readUnsignedByte()/255;switch(t.readByte()){case Ot:x.setStepped(v);break;case _t:L(t,x,M++,v,0,p,P,b,V,1),L(t,x,M++,v,1,p,P,y,k,1),L(t,x,M++,v,2,p,P,S,N,1),L(t,x,M++,v,3,p,P,I,H,1)}p=P,b=V,y=k,S=N,I=H}i.push(x);break}case Xr:{const E=t.readInt(!0),x=new Js(g,E,h);let p=t.readFloat(),b=t.readUnsignedByte()/255,y=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255;for(let I=0,v=0;x.setFrame(I,p,b,y,S),I!=w;I++){const M=t.readFloat(),P=t.readUnsignedByte()/255,V=t.readUnsignedByte()/255,k=t.readUnsignedByte()/255;switch(t.readByte()){case Ot:x.setStepped(I);break;case _t:L(t,x,v++,I,0,p,M,b,P,1),L(t,x,v++,I,1,p,M,y,V,1),L(t,x,v++,I,2,p,M,S,k,1)}p=M,b=P,y=V,S=k}i.push(x);break}case Br:{const E=t.readInt(!0),x=new Qs(g,E,h);let p=t.readFloat(),b=t.readUnsignedByte()/255,y=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,I=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255;for(let V=0,k=0;x.setFrame(V,p,b,y,S,I,v,M,P),V!=w;V++){const N=t.readFloat(),H=t.readUnsignedByte()/255,ft=t.readUnsignedByte()/255,It=t.readUnsignedByte()/255,it=t.readUnsignedByte()/255,Pt=t.readUnsignedByte()/255,gt=t.readUnsignedByte()/255,ye=t.readUnsignedByte()/255;switch(t.readByte()){case Ot:x.setStepped(V);break;case _t:L(t,x,k++,V,0,p,N,b,H,1),L(t,x,k++,V,1,p,N,y,ft,1),L(t,x,k++,V,2,p,N,S,It,1),L(t,x,k++,V,3,p,N,I,it,1),L(t,x,k++,V,4,p,N,v,Pt,1),L(t,x,k++,V,5,p,N,M,gt,1),L(t,x,k++,V,6,p,N,P,ye,1)}p=N,b=H,y=ft,S=It,I=it,v=Pt,M=gt,P=ye}i.push(x);break}case Lr:{const E=t.readInt(!0),x=new tn(g,E,h);let p=t.readFloat(),b=t.readUnsignedByte()/255,y=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,I=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255;for(let P=0,V=0;x.setFrame(P,p,b,y,S,I,v,M),P!=w;P++){const k=t.readFloat(),N=t.readUnsignedByte()/255,H=t.readUnsignedByte()/255,ft=t.readUnsignedByte()/255,It=t.readUnsignedByte()/255,it=t.readUnsignedByte()/255,Pt=t.readUnsignedByte()/255;switch(t.readByte()){case Ot:x.setStepped(P);break;case _t:L(t,x,V++,P,0,p,k,b,N,1),L(t,x,V++,P,1,p,k,y,H,1),L(t,x,V++,P,2,p,k,S,ft,1),L(t,x,V++,P,3,p,k,I,It,1),L(t,x,V++,P,4,p,k,v,it,1),L(t,x,V++,P,5,p,k,M,Pt,1)}p=k,b=N,y=H,S=ft,I=It,v=it,M=Pt}i.push(x);break}case Or:{const E=new Ks(g,t.readInt(!0),h);let x=t.readFloat(),p=t.readUnsignedByte()/255;for(let b=0,y=0;E.setFrame(b,x,p),b!=w;b++){const S=t.readFloat(),I=t.readUnsignedByte()/255;switch(t.readByte()){case Ot:E.setStepped(b);break;case _t:L(t,E,y++,b,0,x,S,p,I,1)}x=S,p=I}i.push(E)}}}}for(let n=0,a=t.readInt(!0);n<a;n++){const h=t.readInt(!0);for(let l=0,u=t.readInt(!0);l<u;l++){const f=t.readByte(),g=t.readInt(!0),w=t.readInt(!0);switch(f){case Ir:i.push(qt(t,new _s(g,w,h),1));break;case Ar:i.push(Me(t,new $s(g,w,h),o));break;case Cr:i.push(qt(t,new Ds(g,w,h),o));break;case vr:i.push(qt(t,new Us(g,w,h),o));break;case Tr:i.push(Me(t,new zs(g,w,h),1));break;case Mr:i.push(qt(t,new Gs(g,w,h),1));break;case Vr:i.push(qt(t,new Hs(g,w,h),1));break;case Fr:i.push(Me(t,new qs(g,w,h),1));break;case Pr:i.push(qt(t,new Ws(g,w,h),1));break;case kr:i.push(qt(t,new Zs(g,w,h),1))}}}for(let n=0,a=t.readInt(!0);n<a;n++){const h=t.readInt(!0),l=t.readInt(!0),u=l-1,f=new on(l,t.readInt(!0),h);let g=t.readFloat(),w=t.readFloat(),E=t.readFloat()*o;for(let x=0,p=0;f.setFrame(x,g,w,E,t.readByte(),t.readBoolean(),t.readBoolean()),x!=u;x++){const b=t.readFloat(),y=t.readFloat(),S=t.readFloat()*o;switch(t.readByte()){case Ot:f.setStepped(x);break;case _t:L(t,f,p++,x,0,g,b,w,y,1),L(t,f,p++,x,1,g,b,E,S,o)}g=b,w=y,E=S}i.push(f)}for(let n=0,a=t.readInt(!0);n<a;n++){const h=t.readInt(!0),l=t.readInt(!0),u=l-1,f=new an(l,t.readInt(!0),h);let g=t.readFloat(),w=t.readFloat(),E=t.readFloat(),x=t.readFloat(),p=t.readFloat(),b=t.readFloat(),y=t.readFloat();for(let S=0,I=0;f.setFrame(S,g,w,E,x,p,b,y),S!=u;S++){const v=t.readFloat(),M=t.readFloat(),P=t.readFloat(),V=t.readFloat(),k=t.readFloat(),N=t.readFloat(),H=t.readFloat();switch(t.readByte()){case Ot:f.setStepped(S);break;case _t:L(t,f,I++,S,0,g,v,w,M,1),L(t,f,I++,S,1,g,v,E,P,1),L(t,f,I++,S,2,g,v,x,V,1),L(t,f,I++,S,3,g,v,p,k,1),L(t,f,I++,S,4,g,v,b,N,1),L(t,f,I++,S,5,g,v,y,H,1)}g=v,w=M,E=P,x=V,p=k,b=N,y=H}i.push(f)}for(let n=0,a=t.readInt(!0);n<a;n++){const h=t.readInt(!0),l=s.pathConstraints[h];for(let u=0,f=t.readInt(!0);u<f;u++)switch(t.readByte()){case $r:i.push(qt(t,new ln(t.readInt(!0),t.readInt(!0),h),l.positionMode==at.Fixed?o:1));break;case Dr:i.push(qt(t,new cn(t.readInt(!0),t.readInt(!0),h),l.spacingMode==$t.Length||l.spacingMode==$t.Fixed?o:1));break;case Ur:const g=new hn(t.readInt(!0),t.readInt(!0),h);let w=t.readFloat(),E=t.readFloat(),x=t.readFloat(),p=t.readFloat();for(let b=0,y=0,S=g.getFrameCount()-1;g.setFrame(b,w,E,x,p),b!=S;b++){const I=t.readFloat(),v=t.readFloat(),M=t.readFloat(),P=t.readFloat();switch(t.readByte()){case Ot:g.setStepped(b);break;case _t:L(t,g,y++,b,0,w,I,E,v,1),L(t,g,y++,b,1,w,I,x,M,1),L(t,g,y++,b,2,w,I,p,P,1)}w=I,E=v,x=M,p=P}i.push(g)}}for(let n=0,a=t.readInt(!0);n<a;n++){const h=s.skins[t.readInt(!0)];for(let l=0,u=t.readInt(!0);l<u;l++){const f=t.readInt(!0);for(let g=0,w=t.readInt(!0);g<w;g++){const E=t.readStringRef();if(!E)throw new Error("attachmentName must not be null.");const x=h.getAttachment(f,E),p=this.readDeformTimelineType(t),b=t.readInt(!0),y=b-1;switch(p){case ns:{const S=x,I=S.bones,v=S.vertices,M=I?v.length/3*2:v.length,P=t.readInt(!0),V=new sn(b,P,f,S);let k=t.readFloat();for(let N=0,H=0;;N++){let ft,It=t.readInt(!0);if(It==0)ft=I?C.newFloatArray(M):v;else{ft=C.newFloatArray(M);const Pt=t.readInt(!0);if(It+=Pt,o==1)for(let gt=Pt;gt<It;gt++)ft[gt]=t.readFloat();else for(let gt=Pt;gt<It;gt++)ft[gt]=t.readFloat()*o;if(!I)for(let gt=0,ye=ft.length;gt<ye;gt++)ft[gt]+=v[gt]}if(V.setFrame(N,k,ft),N==y)break;const it=t.readFloat();switch(t.readByte()){case Ot:V.setStepped(N);break;case _t:L(t,V,H++,N,0,k,it,0,1,1)}k=it}i.push(V);break}case _r:{const S=new pe(b,f,x);for(let I=0;I<b;I++){const v=t.readFloat(),M=t.readInt32();S.setFrame(I,v,Os[M&15],M>>4,t.readFloat())}i.push(S);break}}}}}const m=t.readInt(!0);if(m>0){const n=new He(m),a=s.slots.length;for(let h=0;h<m;h++){const l=t.readFloat(),u=t.readInt(!0),f=C.newArray(a,0);for(let x=a-1;x>=0;x--)f[x]=-1;const g=C.newArray(a-u,0);let w=0,E=0;for(let x=0;x<u;x++){const p=t.readInt(!0);for(;w!=p;)g[E++]=w++;f[w+t.readInt(!0)]=w++}for(;w<a;)g[E++]=w++;for(let x=a-1;x>=0;x--)f[x]==-1&&(f[x]=g[--E]);n.setFrame(h,l,f)}i.push(n)}const d=t.readInt(!0);if(d>0){const n=new Ge(d);for(let a=0;a<d;a++){const h=t.readFloat(),l=s.events[t.readInt(!0)],u=new fn(h,l);u.intValue=t.readInt(!1),u.floatValue=t.readFloat(),u.stringValue=t.readBoolean()?t.readString():l.stringValue,u.data.audioPath&&(u.volume=t.readFloat(),u.balance=t.readFloat()),n.setFrame(a,u)}i.push(n)}let e=0;for(let n=0,a=i.length;n<a;n++)e=Math.max(e,i[n].getDuration());return new Ue(r,i,e)}}pn.BlendModeValues=[et.NORMAL,et.ADD,et.MULTIPLY,et.SCREEN];let Sr=class{constructor(t,r,s,i,o){this.mesh=t,this.skin=r,this.slotIndex=s,this.parent=i,this.inheritTimeline=o}};class Rr{constructor(t=null,r=null){this.bones=t,this.vertices=r}}function qt(c,t,r){let s=c.readFloat(),i=c.readFloat()*r;for(let o=0,m=0,d=t.getFrameCount()-1;t.setFrame(o,s,i),o!=d;o++){const e=c.readFloat(),n=c.readFloat()*r;switch(c.readByte()){case Ot:t.setStepped(o);break;case _t:L(c,t,m++,o,0,s,e,i,n,r)}s=e,i=n}return t}function Me(c,t,r){let s=c.readFloat(),i=c.readFloat()*r,o=c.readFloat()*r;for(let m=0,d=0,e=t.getFrameCount()-1;t.setFrame(m,s,i,o),m!=e;m++){const n=c.readFloat(),a=c.readFloat()*r,h=c.readFloat()*r;switch(c.readByte()){case Ot:t.setStepped(m);break;case _t:L(c,t,d++,m,0,s,n,i,a,r),L(c,t,d++,m,1,s,n,o,h,r)}s=n,i=a,o=h}return t}function L(c,t,r,s,i,o,m,d,e,n){t.setBezier(r,s,i,o,d,c.readFloat(),c.readFloat()*n,c.readFloat(),c.readFloat()*n,m,e)}const Ir=0,Ar=1,Cr=2,vr=3,Tr=4,Mr=5,Vr=6,Fr=7,Pr=8,kr=9,Nr=0,Yr=1,Xr=2,Br=3,Lr=4,Or=5,ns=0,_r=1,$r=0,Dr=1,Ur=2,Ot=1,_t=2;class We{constructor(t){this.scale=1,this.linkedMeshes=new Array,this.attachmentLoader=t}readSkeletonData(t){const r=this.scale,s=new xn,i=typeof t=="string"?JSON.parse(t):t,o=i.skeleton;if(o){s.hash=o.hash,s.version=o.spine;const m=s.version.substr(0,3);if(m!=="4.0"&&m!=="4.1"){const d=`Spine 4.1 loader cant load version ${o.spine}. Please configure your pixi-spine bundle`;console.error(d)}s.x=o.x,s.y=o.y,s.width=o.width,s.height=o.height,s.fps=o.fps,s.imagesPath=o.images}if(i.bones)for(let m=0;m<i.bones.length;m++){const d=i.bones[m];let e=null;const n=A(d,"parent",null);if(n!=null&&(e=s.findBone(n),e==null))throw new Error(`Parent bone not found: ${n}`);const a=new un(s.bones.length,d.name,e);a.length=A(d,"length",0)*r,a.x=A(d,"x",0)*r,a.y=A(d,"y",0)*r,a.rotation=A(d,"rotation",0),a.scaleX=A(d,"scaleX",1),a.scaleY=A(d,"scaleY",1),a.shearX=A(d,"shearX",0),a.shearY=A(d,"shearY",0),a.transformMode=C.enumValue(st,A(d,"transform","Normal")),a.skinRequired=A(d,"skin",!1);const h=A(d,"color",null);h&&a.color.setFromString(h),s.bones.push(a)}if(i.slots)for(let m=0;m<i.slots.length;m++){const d=i.slots[m],e=s.findBone(d.bone);if(!e)throw new Error(`Couldn't find bone ${d.bone} for slot ${d.name}`);const n=new En(s.slots.length,d.name,e),a=A(d,"color",null);a&&n.color.setFromString(a);const h=A(d,"dark",null);h&&(n.darkColor=T.fromString(h)),n.attachmentName=A(d,"attachment",null),n.blendMode=We.blendModeFromString(A(d,"blend","normal")),s.slots.push(n)}if(i.ik)for(let m=0;m<i.ik.length;m++){const d=i.ik[m],e=new gn(d.name);e.order=A(d,"order",0),e.skinRequired=A(d,"skin",!1);for(let n=0;n<d.bones.length;n++){const a=d.bones[n],h=s.findBone(a);if(h==null)throw new Error(`IK bone not found: ${a}`);e.bones.push(h)}e.target=s.findBone(d.target),e.mix=A(d,"mix",1),e.softness=A(d,"softness",0)*r,e.bendDirection=A(d,"bendPositive",!0)?1:-1,e.compress=A(d,"compress",!1),e.stretch=A(d,"stretch",!1),e.uniform=A(d,"uniform",!1),s.ikConstraints.push(e)}if(i.transform)for(let m=0;m<i.transform.length;m++){const d=i.transform[m],e=new bn(d.name);e.order=A(d,"order",0),e.skinRequired=A(d,"skin",!1);for(let h=0;h<d.bones.length;h++){const l=d.bones[h],u=s.findBone(l);if(!u)throw new Error(`Couldn't find bone ${l} for transform constraint ${d.name}.`);e.bones.push(u)}const n=d.target,a=s.findBone(n);if(!a)throw new Error(`Couldn't find target bone ${n} for transform constraint ${d.name}.`);e.target=a,e.local=A(d,"local",!1),e.relative=A(d,"relative",!1),e.offsetRotation=A(d,"rotation",0),e.offsetX=A(d,"x",0)*r,e.offsetY=A(d,"y",0)*r,e.offsetScaleX=A(d,"scaleX",0),e.offsetScaleY=A(d,"scaleY",0),e.offsetShearY=A(d,"shearY",0),e.mixRotate=A(d,"mixRotate",1),e.mixX=A(d,"mixX",1),e.mixY=A(d,"mixY",e.mixX),e.mixScaleX=A(d,"mixScaleX",1),e.mixScaleY=A(d,"mixScaleY",e.mixScaleX),e.mixShearY=A(d,"mixShearY",1),s.transformConstraints.push(e)}if(i.path)for(let m=0;m<i.path.length;m++){const d=i.path[m],e=new wn(d.name);e.order=A(d,"order",0),e.skinRequired=A(d,"skin",!1);for(let h=0;h<d.bones.length;h++){const l=d.bones[h],u=s.findBone(l);if(!u)throw new Error(`Couldn't find bone ${l} for path constraint ${d.name}.`);e.bones.push(u)}const n=d.target,a=s.findSlot(n);if(!a)throw new Error(`Couldn't find target slot ${n} for path constraint ${d.name}.`);e.target=a,e.positionMode=C.enumValue(at,A(d,"positionMode","Percent")),e.spacingMode=C.enumValue($t,A(d,"spacingMode","Length")),e.rotateMode=C.enumValue(vt,A(d,"rotateMode","Tangent")),e.offsetRotation=A(d,"rotation",0),e.position=A(d,"position",0),e.positionMode==at.Fixed&&(e.position*=r),e.spacing=A(d,"spacing",0),(e.spacingMode==$t.Length||e.spacingMode==$t.Fixed)&&(e.spacing*=r),e.mixRotate=A(d,"mixRotate",1),e.mixX=A(d,"mixX",1),e.mixY=A(d,"mixY",e.mixX),s.pathConstraints.push(e)}if(i.skins)for(let m=0;m<i.skins.length;m++){const d=i.skins[m],e=new Ye(d.name);if(d.bones)for(let n=0;n<d.bones.length;n++){const a=d.bones[n],h=s.findBone(a);if(!h)throw new Error(`Couldn't find bone ${a} for skin ${d.name}.`);e.bones.push(h)}if(d.ik)for(let n=0;n<d.ik.length;n++){const a=d.ik[n],h=s.findIkConstraint(a);if(!h)throw new Error(`Couldn't find IK constraint ${a} for skin ${d.name}.`);e.constraints.push(h)}if(d.transform)for(let n=0;n<d.transform.length;n++){const a=d.transform[n],h=s.findTransformConstraint(a);if(!h)throw new Error(`Couldn't find transform constraint ${a} for skin ${d.name}.`);e.constraints.push(h)}if(d.path)for(let n=0;n<d.path.length;n++){const a=d.path[n],h=s.findPathConstraint(a);if(!h)throw new Error(`Couldn't find path constraint ${a} for skin ${d.name}.`);e.constraints.push(h)}for(const n in d.attachments){const a=s.findSlot(n);if(!a)throw new Error(`Couldn't find slot ${n} for skin ${d.name}.`);const h=d.attachments[n];for(const l in h){const u=this.readAttachment(h[l],e,a.index,l,s);u&&e.setAttachment(a.index,l,u)}}s.skins.push(e),e.name=="default"&&(s.defaultSkin=e)}for(let m=0,d=this.linkedMeshes.length;m<d;m++){const e=this.linkedMeshes[m],n=e.skin?s.findSkin(e.skin):s.defaultSkin;if(!n)throw new Error(`Skin not found: ${e.skin}`);const a=n.getAttachment(e.slotIndex,e.parent);if(!a)throw new Error(`Parent mesh not found: ${e.parent}`);e.mesh.timelineAttachment=e.inheritTimeline?a:e.mesh,e.mesh.setParentMesh(a)}if(this.linkedMeshes.length=0,i.events)for(const m in i.events){const d=i.events[m],e=new mn(m);e.intValue=A(d,"int",0),e.floatValue=A(d,"float",0),e.stringValue=A(d,"string",""),e.audioPath=A(d,"audio",null),e.audioPath&&(e.volume=A(d,"volume",1),e.balance=A(d,"balance",0)),s.events.push(e)}if(i.animations)for(const m in i.animations){const d=i.animations[m];this.readAnimation(d,m,s)}return s}readAttachment(t,r,s,i,o){const m=this.scale;switch(i=A(t,"name",i),A(t,"type","region")){case"region":{const d=A(t,"path",i),e=this.readSequence(A(t,"sequence",null)),n=this.attachmentLoader.newRegionAttachment(r,i,d,e);if(!n)return null;n.path=d,n.x=A(t,"x",0)*m,n.y=A(t,"y",0)*m,n.scaleX=A(t,"scaleX",1),n.scaleY=A(t,"scaleY",1),n.rotation=A(t,"rotation",0),n.width=t.width*m,n.height=t.height*m,n.sequence=e;const a=A(t,"color",null);return a&&n.color.setFromString(a),n}case"boundingbox":{const d=this.attachmentLoader.newBoundingBoxAttachment(r,i);if(!d)return null;this.readVertices(t,d,t.vertexCount<<1);const e=A(t,"color",null);return e&&d.color.setFromString(e),d}case"mesh":case"linkedmesh":{const d=A(t,"path",i),e=this.readSequence(A(t,"sequence",null)),n=this.attachmentLoader.newMeshAttachment(r,i,d,e);if(!n)return null;n.path=d;const a=A(t,"color",null);a&&n.color.setFromString(a),n.width=A(t,"width",0)*m,n.height=A(t,"height",0)*m,n.sequence=e;const h=A(t,"parent",null);if(h)return this.linkedMeshes.push(new zr(n,A(t,"skin",null),s,h,A(t,"timelines",!0))),n;const l=t.uvs;return this.readVertices(t,n,l.length),n.triangles=t.triangles,n.regionUVs=new Float32Array(l),n.edges=A(t,"edges",null),n.hullLength=A(t,"hull",0)*2,n}case"path":{const d=this.attachmentLoader.newPathAttachment(r,i);if(!d)return null;d.closed=A(t,"closed",!1),d.constantSpeed=A(t,"constantSpeed",!0);const e=t.vertexCount;this.readVertices(t,d,e<<1);const n=C.newArray(e/3,0);for(let h=0;h<t.lengths.length;h++)n[h]=t.lengths[h]*m;d.lengths=n;const a=A(t,"color",null);return a&&d.color.setFromString(a),d}case"point":{const d=this.attachmentLoader.newPointAttachment(r,i);if(!d)return null;d.x=A(t,"x",0)*m,d.y=A(t,"y",0)*m,d.rotation=A(t,"rotation",0);const e=A(t,"color",null);return e&&d.color.setFromString(e),d}case"clipping":{const d=this.attachmentLoader.newClippingAttachment(r,i);if(!d)return null;const e=A(t,"end",null);if(e!=null){const h=o.findSlot(e);if(h==null)throw new Error(`Clipping end slot not found: ${e}`);d.endSlot=h}const n=t.vertexCount;this.readVertices(t,d,n<<1);const a=A(t,"color",null);return a&&d.color.setFromString(a),d}}return null}readSequence(t){if(t==null)return null;const r=new De(A(t,"count",0));return r.start=A(t,"start",1),r.digits=A(t,"digits",0),r.setupIndex=A(t,"setup",0),r}readVertices(t,r,s){const i=this.scale;r.worldVerticesLength=s;const o=t.vertices;if(s==o.length){const e=C.toFloatArray(o);if(i!=1)for(let n=0,a=o.length;n<a;n++)e[n]*=i;r.vertices=e;return}const m=new Array,d=new Array;for(let e=0,n=o.length;e<n;){const a=o[e++];d.push(a);for(let h=e+a*4;e<h;e+=4)d.push(o[e]),m.push(o[e+1]*i),m.push(o[e+2]*i),m.push(o[e+3])}r.bones=d,r.vertices=C.toFloatArray(m)}readAnimation(t,r,s){const i=this.scale,o=new Array;if(t.slots)for(const d in t.slots){const e=t.slots[d],n=s.findSlot(d);if(!n)throw new Error(`Slot not found: ${d}`);const a=n.index;for(const h in e){const l=e[h];if(!l)continue;const u=l.length;if(h=="attachment"){const f=new en(u,a);for(let g=0;g<u;g++){const w=l[g];f.setFrame(g,A(w,"time",0),A(w,"name",null))}o.push(f)}else if(h=="rgba"){const f=new js(u,u<<2,a);let g=l[0],w=A(g,"time",0),E=T.fromString(g.color);for(let x=0,p=0;;x++){f.setFrame(x,w,E.r,E.g,E.b,E.a);const b=l[x+1];if(!b){f.shrink(p);break}const y=A(b,"time",0),S=T.fromString(b.color),I=g.curve;I&&(p=$(I,f,p,x,0,w,y,E.r,S.r,1),p=$(I,f,p,x,1,w,y,E.g,S.g,1),p=$(I,f,p,x,2,w,y,E.b,S.b,1),p=$(I,f,p,x,3,w,y,E.a,S.a,1)),w=y,E=S,g=b}o.push(f)}else if(h=="rgb"){const f=new Js(u,u*3,a);let g=l[0],w=A(g,"time",0),E=T.fromString(g.color);for(let x=0,p=0;;x++){f.setFrame(x,w,E.r,E.g,E.b);const b=l[x+1];if(!b){f.shrink(p);break}const y=A(b,"time",0),S=T.fromString(b.color),I=g.curve;I&&(p=$(I,f,p,x,0,w,y,E.r,S.r,1),p=$(I,f,p,x,1,w,y,E.g,S.g,1),p=$(I,f,p,x,2,w,y,E.b,S.b,1)),w=y,E=S,g=b}o.push(f)}else if(h=="alpha")o.push(Dt(l,new Ks(u,u,a),0,1));else if(h=="rgba2"){const f=new Qs(u,u*7,a);let g=l[0],w=A(g,"time",0),E=T.fromString(g.light),x=T.fromString(g.dark);for(let p=0,b=0;;p++){f.setFrame(p,w,E.r,E.g,E.b,E.a,x.r,x.g,x.b);const y=l[p+1];if(!y){f.shrink(b);break}const S=A(y,"time",0),I=T.fromString(y.light),v=T.fromString(y.dark),M=g.curve;M&&(b=$(M,f,b,p,0,w,S,E.r,I.r,1),b=$(M,f,b,p,1,w,S,E.g,I.g,1),b=$(M,f,b,p,2,w,S,E.b,I.b,1),b=$(M,f,b,p,3,w,S,E.a,I.a,1),b=$(M,f,b,p,4,w,S,x.r,v.r,1),b=$(M,f,b,p,5,w,S,x.g,v.g,1),b=$(M,f,b,p,6,w,S,x.b,v.b,1)),w=S,E=I,x=v,g=y}o.push(f)}else if(h=="rgb2"){const f=new tn(u,u*6,a);let g=l[0],w=A(g,"time",0),E=T.fromString(g.light),x=T.fromString(g.dark);for(let p=0,b=0;;p++){f.setFrame(p,w,E.r,E.g,E.b,x.r,x.g,x.b);const y=l[p+1];if(!y){f.shrink(b);break}const S=A(y,"time",0),I=T.fromString(y.light),v=T.fromString(y.dark),M=g.curve;M&&(b=$(M,f,b,p,0,w,S,E.r,I.r,1),b=$(M,f,b,p,1,w,S,E.g,I.g,1),b=$(M,f,b,p,2,w,S,E.b,I.b,1),b=$(M,f,b,p,3,w,S,x.r,v.r,1),b=$(M,f,b,p,4,w,S,x.g,v.g,1),b=$(M,f,b,p,5,w,S,x.b,v.b,1)),w=S,E=I,x=v,g=y}o.push(f)}}}if(t.bones)for(const d in t.bones){const e=t.bones[d],n=s.findBone(d);if(!n)throw new Error(`Bone not found: ${d}`);const a=n.index;for(const h in e){const l=e[h],u=l.length;if(u!=0){if(h==="rotate")o.push(Dt(l,new _s(u,u,a),0,1));else if(h==="translate"){const f=new $s(u,u<<1,a);o.push(Ve(l,f,"x","y",0,i))}else if(h==="translatex"){const f=new Ds(u,u,a);o.push(Dt(l,f,0,i))}else if(h==="translatey"){const f=new Us(u,u,a);o.push(Dt(l,f,0,i))}else if(h==="scale"){const f=new zs(u,u<<1,a);o.push(Ve(l,f,"x","y",1,1))}else if(h==="scalex"){const f=new Gs(u,u,a);o.push(Dt(l,f,1,1))}else if(h==="scaley"){const f=new Hs(u,u,a);o.push(Dt(l,f,1,1))}else if(h==="shear"){const f=new qs(u,u<<1,a);o.push(Ve(l,f,"x","y",0,1))}else if(h==="shearx"){const f=new Ws(u,u,a);o.push(Dt(l,f,0,1))}else if(h==="sheary"){const f=new Zs(u,u,a);o.push(Dt(l,f,0,1))}}}}if(t.ik)for(const d in t.ik){const e=t.ik[d];let n=e[0];if(!n)continue;const a=s.findIkConstraint(d);if(!a)throw new Error(`IK Constraint not found: ${d}`);const h=s.ikConstraints.indexOf(a),l=new on(e.length,e.length<<1,h);let u=A(n,"time",0),f=A(n,"mix",1),g=A(n,"softness",0)*i;for(let w=0,E=0;;w++){l.setFrame(w,u,f,g,A(n,"bendPositive",!0)?1:-1,A(n,"compress",!1),A(n,"stretch",!1));const x=e[w+1];if(!x){l.shrink(E);break}const p=A(x,"time",0),b=A(x,"mix",1),y=A(x,"softness",0)*i,S=n.curve;S&&(E=$(S,l,E,w,0,u,p,f,b,1),E=$(S,l,E,w,1,u,p,g,y,i)),u=p,f=b,g=y,n=x}o.push(l)}if(t.transform)for(const d in t.transform){const e=t.transform[d];let n=e[0];if(!n)continue;const a=s.findTransformConstraint(d);if(!a)throw new Error(`Transform constraint not found: ${d}`);const h=s.transformConstraints.indexOf(a),l=new an(e.length,e.length*6,h);let u=A(n,"time",0),f=A(n,"mixRotate",1),g=A(n,"mixX",1),w=A(n,"mixY",g),E=A(n,"mixScaleX",1),x=A(n,"mixScaleY",E);const p=A(n,"mixShearY",1);for(let b=0,y=0;;b++){l.setFrame(b,u,f,g,w,E,x,p);const S=e[b+1];if(!S){l.shrink(y);break}const I=A(S,"time",0),v=A(S,"mixRotate",1),M=A(S,"mixX",1),P=A(S,"mixY",M),V=A(S,"mixScaleX",1),k=A(S,"mixScaleY",V),N=A(S,"mixShearY",1),H=n.curve;H&&(y=$(H,l,y,b,0,u,I,f,v,1),y=$(H,l,y,b,1,u,I,g,M,1),y=$(H,l,y,b,2,u,I,w,P,1),y=$(H,l,y,b,3,u,I,E,V,1),y=$(H,l,y,b,4,u,I,x,k,1),y=$(H,l,y,b,5,u,I,p,N,1)),u=I,f=v,g=M,w=P,E=V,x=k,E=V,n=S}o.push(l)}if(t.path)for(const d in t.path){const e=t.path[d],n=s.findPathConstraint(d);if(!n)throw new Error(`Path constraint not found: ${d}`);const a=s.pathConstraints.indexOf(n);for(const h in e){const l=e[h];let u=l[0];if(!u)continue;const f=l.length;if(h==="position"){const g=new ln(f,f,a);o.push(Dt(l,g,0,n.positionMode==at.Fixed?i:1))}else if(h==="spacing"){const g=new cn(f,f,a);o.push(Dt(l,g,0,n.spacingMode==$t.Length||n.spacingMode==$t.Fixed?i:1))}else if(h==="mix"){const g=new hn(f,f*3,a);let w=A(u,"time",0),E=A(u,"mixRotate",1),x=A(u,"mixX",1),p=A(u,"mixY",x);for(let b=0,y=0;;b++){g.setFrame(b,w,E,x,p);const S=l[b+1];if(!S){g.shrink(y);break}const I=A(S,"time",0),v=A(S,"mixRotate",1),M=A(S,"mixX",1),P=A(S,"mixY",M),V=u.curve;V&&(y=$(V,g,y,b,0,w,I,E,v,1),y=$(V,g,y,b,1,w,I,x,M,1),y=$(V,g,y,b,2,w,I,p,P,1)),w=I,E=v,x=M,p=P,u=S}o.push(g)}}}if(t.deform){t.attachments={};for(const d in t.deform){const e=t.deform[d],n=t.attachments[d]={};for(const a in e){const h=e[a],l=n[a]={};for(const u in h)l[u]={deform:h[u]}}}}if(t.attachments)for(const d in t.attachments){const e=t.attachments[d],n=s.findSkin(d);if(n!=null)for(const a in e){const h=e[a],l=s.findSlot(a);if(!l)throw new Error(`Slot not found: ${a}`);const u=l.index;for(const f in h){const g=h[f],w=n.getAttachment(u,f);for(const E in g){const x=g[E];let p=x[0];if(p){if(E=="deform"){const b=w.bones,y=w.vertices,S=b?y.length/3*2:y.length,I=new sn(x.length,x.length,u,w);let v=A(p,"time",0);for(let M=0,P=0;;M++){let V;const k=A(p,"vertices",null);if(!k)V=b?C.newFloatArray(S):y;else{V=C.newFloatArray(S);const It=A(p,"offset",0);if(C.arrayCopy(k,0,V,It,k.length),i!=1)for(let it=It,Pt=it+k.length;it<Pt;it++)V[it]*=i;if(!b)for(let it=0;it<S;it++)V[it]+=y[it]}I.setFrame(M,v,V);const N=x[M+1];if(!N){I.shrink(P);break}const H=A(N,"time",0),ft=p.curve;ft&&(P=$(ft,I,P,M,0,v,H,0,1,1)),v=H,p=N}o.push(I)}else if(E=="sequence"){const b=new pe(x.length,u,w);let y=0;for(let S=0;S<x.length;S++){const I=A(p,"delay",y),v=A(p,"time",0),M=Wt[A(p,"mode","hold")],P=A(p,"index",0);b.setFrame(S,v,M,P,I),y=I,p=x[S+1]}o.push(b)}}}}}}if(t.drawOrder){const d=new He(t.drawOrder.length),e=s.slots.length;let n=0;for(let a=0;a<t.drawOrder.length;a++,n++){const h=t.drawOrder[a];let l=null;const u=A(h,"offsets",null);if(u){l=C.newArray(e,-1);const f=C.newArray(e-u.length,0);let g=0,w=0;for(let E=0;E<u.length;E++){const x=u[E],p=s.findSlot(x.slot);if(!p)throw new Error(`Slot not found: ${p}`);const b=p.index;for(;g!=b;)f[w++]=g++;l[g+x.offset]=g++}for(;g<e;)f[w++]=g++;for(let E=e-1;E>=0;E--)l[E]==-1&&(l[E]=f[--w])}d.setFrame(n,A(h,"time",0),l)}o.push(d)}if(t.events){const d=new Ge(t.events.length);let e=0;for(let n=0;n<t.events.length;n++,e++){const a=t.events[n],h=s.findEvent(a.name);if(!h)throw new Error(`Event not found: ${a.name}`);const l=new fn(C.toSinglePrecision(A(a,"time",0)),h);l.intValue=A(a,"int",h.intValue),l.floatValue=A(a,"float",h.floatValue),l.stringValue=A(a,"string",h.stringValue),l.data.audioPath&&(l.volume=A(a,"volume",1),l.balance=A(a,"balance",0)),d.setFrame(e,l)}o.push(d)}let m=0;for(let d=0,e=o.length;d<e;d++)m=Math.max(m,o[d].getDuration());if(isNaN(m))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new Ue(r,o,m))}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return et.NORMAL;if(t=="additive")return et.ADD;if(t=="multiply")return et.MULTIPLY;if(t=="screen")return et.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}}class zr{constructor(t,r,s,i,o){this.mesh=t,this.skin=r,this.slotIndex=s,this.parent=i,this.inheritTimeline=o}}function Dt(c,t,r,s){let i=c[0],o=A(i,"time",0),m=A(i,"value",r)*s,d=0;for(let e=0;;e++){t.setFrame(e,o,m);const n=c[e+1];if(!n)return t.shrink(d),t;const a=A(n,"time",0),h=A(n,"value",r)*s;i.curve&&(d=$(i.curve,t,d,e,0,o,a,m,h,s)),o=a,m=h,i=n}}function Ve(c,t,r,s,i,o){let m=c[0],d=A(m,"time",0),e=A(m,r,i)*o,n=A(m,s,i)*o,a=0;for(let h=0;;h++){t.setFrame(h,d,e,n);const l=c[h+1];if(!l)return t.shrink(a),t;const u=A(l,"time",0),f=A(l,r,i)*o,g=A(l,s,i)*o,w=m.curve;w&&(a=$(w,t,a,h,0,d,u,e,f,o),a=$(w,t,a,h,1,d,u,n,g,o)),d=u,e=f,n=g,m=l}}function $(c,t,r,s,i,o,m,d,e,n){if(c=="stepped")return t.setStepped(s),r;const a=i<<2,h=c[a],l=c[a+1]*n,u=c[a+2],f=c[a+3]*n;return t.setBezier(r,s,i,o,d,h,l,u,f,m,e),r+1}function A(c,t,r){return c[t]!==void 0?c[t]:r}var re=(c=>(c[c.UNKNOWN=0]="UNKNOWN",c[c.VER37=37]="VER37",c[c.VER38=38]="VER38",c[c.VER40=40]="VER40",c[c.VER41=41]="VER41",c))(re||{});function Xe(c){const t=c.substr(0,3),r=Math.floor(Number(t)*10+.001);return t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:r<37?37:0}class Gr{constructor(){this.scale=1}readSkeletonData(t,r){let s=null,i=this.readVersionOldFormat(r),o=Xe(i);if(o===re.VER38&&(s=new ot(new As(t))),i=this.readVersionNewFormat(r),o=Xe(i),(o===re.VER40||o===re.VER41)&&(s=new pn(new dn(t))),!s){const m=`Unsupported version of spine model ${i}, please update pixi-spine`;console.error(m)}return s.scale=this.scale,s.readSkeletonData(r)}readVersionOldFormat(t){const r=new Ce(t);let s;try{r.readString(),s=r.readString()}catch{s=""}return s||""}readVersionNewFormat(t){const r=new Ce(t);r.readInt32(),r.readInt32();let s;try{s=r.readString()}catch{s=""}return s||""}}class Hr{constructor(){this.scale=1}readSkeletonData(t,r){const s=r.skeleton.spine,i=Xe(s);let o=null;if(i===re.VER37&&(o=new pr(new hr(t))),i===re.VER38&&(o=new Zn(new As(t))),(i===re.VER40||i===re.VER41)&&(o=new We(new dn(t))),!o){const m=`Unsupported version of spine model ${s}, please update pixi-spine`;console.error(m)}return o.scale=this.scale,o.readSkeletonData(r)}}class qr extends $n{createBinaryParser(){return new Gr}createJsonParser(){return new Hr}parseData(t,r,s){return{spineData:t.readSkeletonData(r,s),spineAtlas:r}}}new qr().installLoader();
